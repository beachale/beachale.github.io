<!DOCTYPE html>

<html lang="en">
<head>
<style id="hide-upscaled-tolerance">#upTolWrapLeft, #upTolWrapTop { display: none !important; }</style>
<meta charset="utf-8"/>
<meta content="width=device-width, initial-scale=1" name="viewport"/>
<title>MERS Texture Lab – Clean Rebuild</title>
<style>
  :root {
    --bg: #0f1120;
    --bg-panel: #161829;
    --bg-alt: #1d2040;
    --text: #e6e7ef;
    --muted: #a3a7c2;
    --primary: #8b5cf6;   /* violet */
    --accent: #22d3ee;    /* cyan */
    --warning: #f59e0b;
    --danger: #ef4444;
    --ok: #10b981;
    --border: #2a2d4b;
    --chip: #242743;
  }
  * { box-sizing: border-box; }
  html, body { height: 100%; }
  body {
    margin: 0;
    font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, "Helvetica Neue", Arial, "Noto Sans", "Apple Color Emoji", "Segoe UI Emoji";
    background: linear-gradient(135deg, #241b4b 0%, #0f1120 50%, #111827 100%);
    color: var(--text);
  }
  header {
    padding: 18px 22px;
    position: sticky; top: 0; z-index: 10;
    backdrop-filter: blur(12px);
    background: linear-gradient(90deg, rgba(13,14,30,.7), rgba(21,24,54,.7));
    border-bottom: 1px solid var(--border);
    display: flex; align-items: center; gap: 14px; flex-wrap: wrap;
  }
  header h1 { margin: 0; font-size: 20px; letter-spacing: .2px; }
  header .sub { color: var(--muted); font-size: 12px; }
  .pill { padding: 6px 10px; border-radius: 999px; background: var(--chip); border: 1px solid var(--border); font-size: 12px; }

  .wrap { display: grid; grid-template-columns: minmax(440px, 520px) 1fr; gap: 16px; padding: 16px; }
  .left { height: calc(100vh - 88px); overflow: auto; padding-right: 4px; }
  .panel { background: var(--bg-panel); border: 1px solid var(--border); border-radius: 14px; padding: 14px; }
  .panel h3 { margin: 0 0 10px; font-size: 14px; letter-spacing: .4px; color: var(--muted); }
  .panel + .panel { margin-top: 12px; }

  .upload { border: 1px dashed var(--border); background: var(--bg-alt); padding: 16px; border-radius: 12px; text-align: center; }
  .upload:hover { border-color: var(--primary); }
  .upload input { display: none; }
  .btn { cursor: pointer; border: 1px solid var(--border); background: #1a1d37; color: var(--text); border-radius: 10px; padding: 8px 12px; font-size: 13px; }
  .btn.primary { background: linear-gradient(90deg, #7c3aed, #06b6d4); border: none; }
  .btn.ghost { background: transparent; }
  .btn.small { padding: 6px 10px; font-size: 12px; }
  .btn.icon { width: 32px; height: 32px; display: grid; place-items: center; padding: 0; }
  .row { display: flex; align-items: center; gap: 10px; flex-wrap: wrap; }

  .group { display: grid; gap: 9px; }
  .slider-row { display: grid; grid-template-columns: 120px 1fr 64px; align-items: center; gap: 10px; }
  .slider-row-anim { display: grid; grid-template-columns: 120px 1fr 80px 64px; align-items: center; gap: 10px; }
  .slider-row label { color: var(--muted); font-size: 12px; }
  input[type=range] { width: 100%; accent-color: var(--primary); }
  .switch { display: inline-flex; gap: 8px; align-items: center; font-size: 12px; color: var(--muted); }

  .curve { width: 100%; height: 140px; border-radius: 10px; background: #0f1228; border: 1px solid var(--border); display: block; cursor: crosshair; }

  .right {
    position: sticky; top: 88px; align-self: start; display: grid; grid-template-rows: auto 1fr auto; gap: 12px;
  }
  .previewShell { display: grid; grid-template-columns: 1fr 1fr; gap: 12px; }
  .canvasWrap { position: relative; background: repeating-conic-gradient(#2a2d4b 0 25%, #1c1f35 0 50%) 50%/20px 20px; border: 1px solid var(--border); border-radius: 12px; overflow: hidden; }
  .canvasHeader { display: flex; align-items: center; justify-content: space-between; padding: 8px 10px; border-bottom: 1px solid var(--border); background: rgba(0,0,0,.25); }
  .canvasHeader .title { font-size: 12px; color: var(--muted); }
  canvas.preview { display: block; width: 100%; height: 100%; image-rendering: pixelated; }
  .toolbar { display: flex; gap: 8px; align-items: center; }
  .chip { padding: 4px 8px; border-radius: 999px; font-size: 11px; border: 1px solid var(--border); background: var(--chip); color: var(--muted); }

  .strip { display: grid; grid-template-columns: repeat(5, auto); gap: 6px; }
  .strip .btn { padding: 6px 8px; font-size: 12px; }

  .histogram { position: fixed; bottom: 18px; right: 18px; width: 420px; height: 260px; background: var(--bg-panel); border: 1px solid var(--border); border-radius: 14px; display: none; flex-direction: column; }
  .histogram.dragging { opacity: .9; }
  .histTop { padding: 8px; display: flex; align-items: center; justify-content: space-between; border-bottom: 1px solid var(--border); }
  .histTop .title { font-size: 12px; color: var(--muted); }
  #histCanvas { width: 100%; height: 100%; display: block; }
  .histBtn { background: transparent; border: 1px solid var(--border); color: var(--muted); border-radius: 8px; padding: 4px 8px; cursor: pointer; }
  .fab { position: fixed; bottom: 18px; right: 18px; width: 44px; height: 44px; border-radius: 50%; background: linear-gradient(135deg, #06b6d4, #7c3aed); border: none; color: white; font-size: 18px; display: grid; place-items: center; cursor: pointer; }

  .grid-2 { display: grid; grid-template-columns: 1fr 1fr; gap: 10px; }
  .curvesGrid { grid-template-columns: 1fr !important; gap: 16px; }
  .mt { margin-top: 10px; }
  .muted { color: var(--muted); }

  .footerRow { display: flex; flex-wrap: wrap; gap: 8px; justify-content: space-between; align-items: center; }

  /* small screens */
  @media (max-width: 1100px) {
    .wrap { grid-template-columns: 1fr; }
    .right { position: static; }
    .previewShell { grid-template-columns: 1fr; }
  }

  /* Lock preview row height so tall reference TGAs don't expand layout */
  #wrapOut, #wrapRef, #wrapSrc { height: 384px; }
</style>
</head>
<body>
<header>
<h1>MERS Texture Lab</h1>
<span class="sub">PNG ⇢ MERS TGA (Metalness • Emissive • Roughness • SSS)</span>
<span class="pill">Dark UI • Zoom/Pan • Curves • Histogram • Noise • Animation</span>
<div style="flex:1"></div>
<button class="btn small" id="darkToggle">🌙 Dark mode</button>
</header>
<div class="wrap">
<!-- LEFT -->
<div class="left">
<div class="panel upload">
<h3>Texture input</h3>
<p class="muted">Drop a PNG/TGA here or pick a file.</p>
<div class="row mt">
<button class="btn" id="pickTex">Choose PNG/TGA</button>
<input accept=".png,.tga" id="fileTex" type="file"/>
<span class="chip" id="texName">No texture</span>
</div>
<hr style="border:none;border-top:1px solid var(--border);margin:12px 0"/>
<h3>Reference MERS (optional)</h3>
<p class="muted">Load a .tga MERS file to preview beside your result or drive per-pixel mapping.</p>
<div class="row mt">
<button class="btn" id="pickRef">Choose TGA</button>
<input accept=".tga" id="fileRef" type="file"/>
<span class="chip" id="refName">No reference</span>
</div>
<div class="row mt">
<label class="switch"><input id="useRefMap" type="checkbox"/> Use reference as per-pixel map</label>
<select class="btn refMatchSel" id="refMatchLeft">
<option value="color">Match colors</option>
<option value="pixel">Match by pixel</option>
<option value="upscaled_v2">Upscaled (unreliable)</option>
<option value="vanilla_tga">For weird mers uv map</option>
</select>
<label class="switch"><input id="invertAll" type="checkbox"/> Invert all channels</label>
<label class="switch"><input id="grayscaleMode" type="checkbox"/> Grayscale channel preview</label>
</div>
</div>
<div class="panel">
<h3>Curves</h3>
<div class="row mt">
<button class="btn" id="resetSliders">Reset sliders</button>
<button class="btn ghost" id="resetCurves">Reset curves</button>
</div>
<div class="grid-2 curvesGrid">
<div>
<div class="row" style="justify-content:space-between"><span class="chip">Red • Metalness</span><span class="muted">click to add • drag • right‑click to delete</span></div>
<div class="group" id="groupR"></div>
<canvas class="curve" height="160" id="curveR" width="520"></canvas>
</div>
<div>
<div class="row" style="justify-content:space-between"><span class="chip">Green • Emissive</span><span class="muted">click to add • drag • right‑click to delete</span></div>
<div class="group" id="groupG"></div>
<canvas class="curve" height="160" id="curveG" width="520"></canvas>
</div>
<div>
<div class="row" style="justify-content:space-between"><span class="chip">Blue • Roughness</span><span class="muted">click to add • drag • right‑click to delete</span></div>
<div class="group" id="groupB"></div>
<canvas class="curve" height="160" id="curveB" width="520"></canvas>
</div>
<div>
<div class="row" style="justify-content:space-between"><span class="chip">Alpha • Subsurface</span><span class="muted">click to add • drag • right‑click to delete</span></div>
<div class="group" id="groupA"></div>
<canvas class="curve" height="160" id="curveA" width="520"></canvas>
</div>
</div>
</div>
<div class="panel">
<h3>Noise</h3>
<div class="grid-2">
<div class="group">
<div class="slider-row"><label for="noiseScale">Scale</label><input id="noiseScale" max="256" min="2" type="range" value="32"/><span id="noiseScaleV">32</span></div>
<div class="slider-row"><label for="noiseAmp">Amplitude</label><input id="noiseAmp" max="255" min="0" type="range" value="0"/><span id="noiseAmpV">0</span></div>
<div class="row">
<select class="btn" id="noiseType">
<option value="perlin">Perlin</option>
<option value="mojang">Mojang experimental noise</option>
<option disabled="" value="custom">Custom (coming)</option>
</select>
<select class="btn" id="noiseChannel">
<option value="none">No channel</option>
<option value="r">Red (Metalness)</option>
<option value="g">Green (Emissive)</option>
<option value="b">Blue (Roughness)</option>
<option value="a">Alpha (SSS)</option>
</select>
<input class="btn" id="noiseSeedInput" placeholder="Seed" style="width:120px" type="number"/>
<button class="btn" id="noiseSeedBtn">New seed</button>
<label class="switch"><input id="rememberSeed" type="checkbox"> Remember</input></label>
</div>
</div>
<div class="group">
<label class="switch"><input id="noiseEnabled" type="checkbox"/> Apply noise to selected channel</label>
<label class="switch"><input checked="" id="noiseMaskAlpha" type="checkbox"/> Only on non‑transparent pixels</label>
<p class="muted">Noise is generated at the texture resolution and previewed/exported into the chosen channel.</p>
</div>
</div>
</div>
<div class="panel">
<h3>Animation</h3>
<div class="grid-2">
<div class="group">
<div class="slider-row slider-row-anim"><label for="frameW">Frame width</label><input id="frameW" max="4096" min="8" step="1" type="range" value="16"/><input class="btn" id="frameWn" max="4096" min="8" step="1" style="width:80px" type="number" value="16"/><span id="frameWV">16</span></div>
<div class="slider-row slider-row-anim"><label for="frameH">Frame height</label><input id="frameH" max="4096" min="8" step="1" type="range" value="16"/><input class="btn" id="frameHn" max="4096" min="8" step="1" style="width:80px" type="number" value="16"/><span id="frameHV">16</span></div>
<div class="slider-row slider-row-anim"><label for="frameMs">Frame time (ms)</label><input id="frameMs" max="1000" min="30" type="range" value="120"/><input class="btn" id="frameMsn" max="1000" min="30" step="1" style="width:80px" type="number" value="120"/><span id="frameMsV">120</span></div>
</div>
<div class="group">
<label class="switch"><input id="animOn" type="checkbox"/> Animate (frames stacked top→bottom)</label>
<div class="row"><span class="muted">Index</span><input class="btn" id="frameIndex" min="0" style="width:80px" type="number" value="0"/></div>
</div>
</div>
</div>
<!-- Painting tool panel -->
<div class="panel">
<h3>Paint</h3>
<div class="row mt">
<label class="switch" style="display:flex;align-items:center;gap:6px;font-size:12px;"><span>Color</span><input id="brushColor" style="width:32px;height:32px;border:none;padding:0;margin:0;" type="color" value="#ff0000"/></label>
<label class="switch" style="display:flex;align-items:center;gap:6px;font-size:12px;"><span>Size</span><input class="btn" id="brushSize" max="64" min="1" style="width:60px" type="number" value="1"/></label>
<button class="btn" id="toggleBrush">🖌️ Brush: Off</button>
<button class="btn" id="toggleBucket">🪣 Bucket: Off</button>
<button class="btn" id="toggleSelect">🎯 Select: Off</button>
<button class="btn" id="toggleEyedropper">🧪 Eyedropper: Off</button>
<button class="btn" disabled="" id="fillSelection">🎨 Fill</button>
<button class="btn small" disabled="" id="clearSelection">✕ Clear</button>
<button class="btn small" disabled="" id="undoPaint" title="Undo last stroke">↺ Undo</button>
<button class="btn small" disabled="" id="redoPaint" title="Redo">↻ Redo</button>
</div>
<div class="row" style="margin-top:4px">
<label class="switch" style="display:flex;align-items:center;gap:6px;font-size:12px;"><input id="brushCopyAlpha" style="margin:0" type="checkbox"/><span>Copy transparency</span></label>
</div>
<p class="muted" style="margin-top:8px">With the Eyedropper, click any preview to pick a colour (and optionally its transparency), then paint on the left preview. Use Select tool to select pixels of the same color value in single-channel mode, then Fill to apply color to selection. Hold Shift to add another colour/value to the current selection. Use right-click to pan when tools are enabled.</p>
</div>
<div class="panel" id="layersPanel">
<h3>Layers</h3>
<div class="layersList">
<div class="layer-row" data-layer="brush">
<button class="btn icon eye" id="layer_vis_brush" title="Show/Hide">👁</button>
<span class="layer-name">🖌️ Brush</span>
</div>
<div class="layer-row" data-layer="bucket">
<button class="btn icon eye" id="layer_vis_bucket" title="Show/Hide">👁</button>
<span class="layer-name">🪣 Bucket</span>
</div>
<div class="layer-row" data-layer="sliders">
<button class="btn icon eye" id="layer_vis_sliders" title="Show/Hide">👁</button>
<span class="layer-name">🎛️ Sliders</span>
</div>
<div class="layer-row" data-layer="curves">
<button class="btn icon eye" id="layer_vis_curves" title="Show/Hide">👁</button>
<span class="layer-name">📈 Curves (mask)</span>
</div>
<div class="layer-row" data-layer="noise">
<button class="btn icon eye" id="layer_vis_noise" title="Show/Hide">👁</button>
<span class="layer-name">✨ Noise</span>
</div>
</div>
<p class="muted" style="margin-top:6px">Top overrides bottom. Click 👁 to toggle visibility.</p>
</div>
<style id="layersPanelStyle">
        #layersPanel .layersList { display:flex; flex-direction:column; gap:4px; }
        #layersPanel .layer-row { display:flex; align-items:center; gap:10px; padding:6px 0; border-bottom:1px dashed var(--muted); }
        #layersPanel .layer-row:last-child{ border-bottom:none; }
        #layersPanel .layer-name { font-weight:600; font-size:12px; }
        #layersPanel .eye { width:30px; min-width:30px; text-align:center; }
        #layersPanel .eye.off { opacity:0.4; }
      </style><div class="panel">
<h3>Export</h3>
<div class="row">
<button class="btn primary" id="saveTGA">Export MERS .tga</button>
<button class="btn" id="saveZIP">Export channels (.zip)</button>
<span class="muted" id="dimInfo"></span>
</div>
</div>
</div>
<!-- RIGHT -->
<div class="right">
<div class="panel">
<div class="row" style="justify-content:space-between">
<div class="strip">
<button class="btn small" data-mode="rgba">RGBA</button>
<button class="btn small" data-mode="r">R</button>
<button class="btn small" data-mode="g">G</button>
<button class="btn small" data-mode="b">B</button>
<button class="btn small" data-mode="a">A</button>
</div>
<div class="row">
<label class="switch"><input id="useRefMapTop" type="checkbox"/> Use ref map</label>
<select class="btn refMatchSel" id="refMatchTop">
<option value="color">Match colors</option>
<option value="pixel">Match by pixel</option>
<option value="upscaled_v2">Upscaled (unreliable)</option>
<option value="vanilla_tga">For weird mers uv map</option>
</select>
<label class="switch"><input id="grayscaleTop" type="checkbox"/> Grayscale</label>
<button class="btn icon" id="zoomOut">−</button>
<span class="chip" id="zoomVal">100%</span>
<button class="btn icon" id="zoomIn">＋</button>
<button class="btn icon" id="zoomReset" title="Reset view">⤾</button>
</div>
</div>
</div>
<div class="previewShell">
<div class="canvasWrap" id="wrapOut">
<div class="canvasHeader"><span class="title">Your MERS preview</span><div class="toolbar"><span class="chip" id="outInfo">—</span></div></div>
<canvas class="preview" height="384" id="canvasOut" width="384"></canvas>
<canvas class="preview" height="384" id="canvasPaint" style="position:absolute;top:0;left:0;width:100%;height:100%;pointer-events:none;" width="384"></canvas>
<canvas class="preview" height="384" id="canvasSelection" style="position:absolute;top:0;left:0;width:100%;height:100%;pointer-events:none;" width="384"></canvas>
</div>
<div class="canvasWrap" id="wrapRef">
<div class="canvasHeader"><span class="title">Reference TGA</span><div class="toolbar"><span class="chip" id="refInfo">—</span></div></div>
<canvas class="preview" height="384" id="canvasRef" width="384"></canvas>
<!-- Overlay canvas for selection on the reference preview.  This mirrors the selection outline drawn on
           the output canvas to provide visual feedback when matching colours between source and reference.
           It is positioned absolutely within the wrapper so it can track pan/zoom and the header height. -->
<canvas class="preview" height="384" id="canvasSelectionRef" style="position:absolute;top:0;left:0;width:100%;height:100%;pointer-events:none;" width="384"></canvas>
</div><div class="canvasWrap" id="wrapSrc">
<div class="canvasHeader"><span class="title">Original texture</span><div class="toolbar"><span class="chip" id="srcInfo">—</span></div></div>
<canvas class="preview" height="384" id="canvasSrc" width="384"></canvas>
</div>
</div>
<!-- Layers Panel (Photoshop/GIMP style) -->
<div class="panel footerRow">
<div class="row">
<button class="btn" id="toggleHist">📊 Histogram</button>
<span class="muted">Drag to move • hide with ×</span>
</div>
<span class="muted">Tip: drag on preview to pan • wheel to zoom • right‑click curve points to delete</span>
</div>
</div>
</div>
<!-- Floating Histogram -->
<div class="histogram" id="histWin">
<div class="histTop" id="histDrag">
<span class="title">Channel histogram (current result)</span>
<div class="row">
<button class="histBtn" id="histHide">×</button>
</div>
</div>
<canvas height="210" id="histCanvas" width="420"></canvas>
</div>
<script>
/***********************
 * Core Module System   *
 ***********************/

// Global namespace for all modules
window.MERS = {};

/***********************
 * Utilities Module     *
 ***********************/
MERS.Utils = (function() {
  'use strict';
  
  const clamp = (v, min = 0, max = 255) => Math.max(min, Math.min(max, v));
  const lerp = (a, b, t) => a + (b - a) * t;
  const $ = sel => document.querySelector(sel);
  const toGray = (r, g, b) => Math.round(0.2126 * r + 0.7152 * g + 0.0722 * b);

  return {
    clamp,
    lerp,
    $,
    toGray
  };
})();

/***********************
 * State Manager Module *
 ***********************/
MERS.StateManager = (function() {
  'use strict';
  
  const state = {
    src: null,
    ref: null,
    mappingOn: false,
    refMatch: 'color',
    mode: 'rgba',
    grayscale: false,
    invertAll: false,
    zoom: 1,
    panX: 0,
    panY: 0,
    noise: {
      enabled: false,
      type: 'perlin',
      channel: 'none',
      scale: 32,
      amp: 0,
      seed: 1337,
      maskAlpha: true
    },
    anim: {
      on: false,
      w: 16,
      h: 16,
      ms: 120,
      i: 0,
      timer: null
    },
    sliders: {
      r: { base: 128, infl: 50, bright: 0, contrast: 100, invert: false },
      g: { base: 0, infl: 25, bright: 0, contrast: 100, invert: false },
      b: { base: 128, infl: 75, bright: 0, contrast: 100, invert: false },
      a: { base: 0, infl: 30, bright: 0, contrast: 100, invert: false },
    },
    curves: {
      r: [{ x: 0, y: 160 }, { x: 520, y: 0 }],
      g: [{ x: 0, y: 160 }, { x: 520, y: 0 }],
      b: [{ x: 0, y: 160 }, { x: 520, y: 0 }],
      a: [{ x: 0, y: 160 }, { x: 520, y: 0 }],
    },
    out: null,
    refMapByColor: null,
    refRes: null
  };

  const paintState = {
    enabled: false,
    painting: false,
    color: { r: 255, g: 0, b: 0, a: 255 },
    bucket: false,
    select: false,
    eyedropper: false,
    size: 1,
    layer: null,
    mask: null,
    selection: null, // Uint8Array for selected pixels
    undoStack: [],
    redoStack: [],
    copyAlpha: false
  };

  return {
    getState: () => state,
    getPaintState: () => paintState,
    updateState: (updates) => Object.assign(state, updates),
    updatePaintState: (updates) => Object.assign(paintState, updates),
    resetSliders: () => {
      state.sliders = {
        r: { base: 128, infl: 50, bright: 0, contrast: 100, invert: false },
        g: { base: 0, infl: 25, bright: 0, contrast: 100, invert: false },
        b: { base: 128, infl: 75, bright: 0, contrast: 100, invert: false },
        a: { base: 0, infl: 30, bright: 0, contrast: 100, invert: false },
      };
    },
    resetCurves: () => {
      state.curves = {
        r: [{ x: 0, y: 160 }, { x: 520, y: 0 }],
        g: [{ x: 0, y: 160 }, { x: 520, y: 0 }],
        b: [{ x: 0, y: 160 }, { x: 520, y: 0 }],
        a: [{ x: 0, y: 160 }, { x: 520, y: 0 }],
      };
    }
  };
})();

/***********************
 * Noise Generator Module *
 ***********************/
MERS.NoiseGenerator = (function() {
  'use strict';
  
  const { lerp } = MERS.Utils;
  let perlin = null;

  function RNG(seed) {
    let s = seed >>> 0;
    return () => (s = (s * 1664525 + 1013904223) >>> 0) / 4294967296;
  }

  function makePerlin(seed = 1337) {
    const rnd = RNG(seed);
    const perm = new Uint8Array(512);
    for (let i = 0; i < 256; i++) perm[i] = i;
    for (let i = 255; i > 0; i--) {
      const j = Math.floor(rnd() * (i + 1));
      const t = perm[i];
      perm[i] = perm[j];
      perm[j] = t;
    }
    for (let i = 0; i < 256; i++) perm[256 + i] = perm[i];

    function fade(t) { return t * t * t * (t * (t * 6 - 15) + 10); }
    function grad(h, x, y) {
      const u = (h & 1) ? x : -x;
      const v = (h & 2) ? y : -y;
      return u + v;
    }

    return function(x, y) {
      const X = Math.floor(x) & 255, Y = Math.floor(y) & 255;
      x -= Math.floor(x);
      y -= Math.floor(y);
      const u = fade(x), v = fade(y);
      const A = perm[X] + Y, B = perm[X + 1] + Y;
      const n00 = grad(perm[A] & 3, x, y);
      const n10 = grad(perm[B] & 3, x - 1, y);
      const n01 = grad(perm[A + 1] & 3, x, y - 1);
      const n11 = grad(perm[B + 1] & 3, x - 1, y - 1);
      return lerp(lerp(n00, n10, u), lerp(n01, n11, u), v) * 0.5 + 0.5;
    };
  }

  // Mojang noise implementation
  function mo_lerp(a, b, t) { return a + (b - a) * t; }
  function mo_create2DArray(rows, cols) { return Array.from({ length: rows }, () => new Array(cols).fill(0)); }
  function mo_mulberry32(seed) {
    return function() {
      seed |= 0;
      seed = seed + 0x6D2B79F5 | 0;
      let t = Math.imul(seed ^ seed >>> 15, 1 | seed);
      t = t + Math.imul(t ^ t >>> 7, 61 | t) ^ t;
      return ((t ^ t >>> 14) >>> 0) / 4294967296;
    };
  }

  function mo_generateValueNoise(width, height, gridSize, seed) {
    const grid = mo_create2DArray(gridSize, gridSize);
    const rand = mo_mulberry32(seed);
    for (let y = 0; y < gridSize; y++) {
      for (let x = 0; x < gridSize; x++) {
        grid[y][x] = rand();
      }
    }
    const noise = mo_create2DArray(height, width);
    const scaleX = (gridSize - 1) / width;
    const scaleY = (gridSize - 1) / height;
    for (let y = 0; y < height; y++) {
      for (let x = 0; x < width; x++) {
        const gx = x * scaleX;
        const gy = y * scaleY;
        const x0 = Math.floor(gx), x1 = Math.min(x0 + 1, gridSize - 1);
        const y0 = Math.floor(gy), y1 = Math.min(y0 + 1, gridSize - 1);
        const sx = gx - x0;
        const sy = gy - y0;

        const n00 = grid[y0][x0];
        const n10 = grid[y0][x1];
        const n01 = grid[y1][x0];
        const n11 = grid[y1][x1];

        const ix0 = mo_lerp(n00, n10, sx);
        const ix1 = mo_lerp(n01, n11, sx);
        const value = mo_lerp(ix0, ix1, sy);

        noise[y][x] = value;
      }
    }
    return noise;
  }

  function mo_generateMultiOctaveNoise(width, height, gridSizes, weights, seed) {
    const noise = mo_create2DArray(height, width);
    let totalWeight = 0;
    for (let o = 0; o < gridSizes.length; o++) {
      const g = gridSizes[o];
      const weight = weights[o];
      totalWeight += weight;
      const octave = mo_generateValueNoise(width, height, g, seed + o);
      for (let y = 0; y < height; y++) {
        for (let x = 0; x < width; x++) {
          noise[y][x] += weight * octave[y][x];
        }
      }
    }
    for (let y = 0; y < height; y++) {
      for (let x = 0; x < width; x++) {
        noise[y][x] /= totalWeight;
      }
    }
    return noise;
  }

  let mojangCache = null;

  function ensureMojangCache() {
    const state = MERS.StateManager.getState();
    if (!state || !state.src) return null;
    const w = state.src.width, h = state.src.height;
    const meta = mojangCache ? mojangCache.meta : {};
    const needRebuild = !mojangCache ||
      meta.w !== w || meta.h !== h ||
      meta.seed !== state.noise.seed ||
      meta.scale !== state.noise.scale;
    if (needRebuild) {
      const g1 = Math.max(2, Math.floor(state.noise.scale / 2));
      const g2 = Math.max(g1 + 1, Math.floor(state.noise.scale));
      const field = mo_generateMultiOctaveNoise(w, h, [g1, g2], [0.7, 0.3], state.noise.seed);
      mojangCache = { field, meta: { w, h, seed: state.noise.seed, scale: state.noise.scale } };
    }
    return mojangCache.field;
  }

  function getNoise(xx, yy) {
    const state = MERS.StateManager.getState();
    if (state && state.noise && state.noise.type === 'mojang') {
      const field = ensureMojangCache();
      if (!field) return 0;
      const x = Math.max(0, Math.min(state.src.width - 1, Math.round(xx * state.noise.scale)));
      const y = Math.max(0, Math.min(state.src.height - 1, Math.round(yy * state.noise.scale)));
      return field[y][x];
    }
    if (!perlin) perlin = makePerlin(state.noise.seed);
    return perlin(xx, yy);
  }

  function updateSeed(seed) {
    perlin = makePerlin(seed);
    mojangCache = null;
  }

  return {
    getNoise,
    updateSeed,
    makePerlin
  };
})();

/***********************
 * Image Processor Module *
 ***********************/
MERS.ImageProcessor = (function() {
  'use strict';
  
  const { clamp, toGray } = MERS.Utils;

  function parseTGA(view) {
    const idLen = view.getUint8(0), imageType = view.getUint8(2);
    const width = view.getUint16(12, true), height = view.getUint16(14, true);
    const bpp = view.getUint8(16);
    const desc = view.getUint8(17);
    if (imageType !== 2 || (bpp !== 24 && bpp !== 32)) throw new Error('Unsupported TGA');
    const bytes = bpp / 8;
    const start = 18 + idLen;
    const data = new Uint8ClampedArray(width * height * 4);
    const originTop = (desc & 0x20) !== 0;
    let p = start;
    for (let y = 0; y < height; y++) {
      const row = originTop ? y : (height - 1 - y);
      for (let x = 0; x < width; x++) {
        const i = (row * width + x) * 4;
        const B = view.getUint8(p++), G = view.getUint8(p++), R = view.getUint8(p++);
        const A = (bytes === 4) ? view.getUint8(p++) : 255;
        data[i] = R;
        data[i + 1] = G;
        data[i + 2] = B;
        data[i + 3] = A;
      }
    }
    return new ImageData(data, width, height);
  }

  function encodeTGA(imgd) {
    const w = imgd.width, h = imgd.height;
    const header = new Uint8Array(18);
    header[2] = 2;
    header[12] = w & 255;
    header[13] = (w >> 8) & 255;
    header[14] = h & 255;
    header[15] = (h >> 8) & 255;
    header[16] = 32;
    header[17] = 0x20;
    const out = new Uint8Array(18 + w * h * 4);
    out.set(header, 0);
    let p = 18;
    const d = imgd.data;
    for (let y = 0; y < h; y++) {
      for (let x = 0; x < w; x++) {
        const i = (y * w + x) * 4;
        out[p++] = d[i + 2];
        out[p++] = d[i + 1];
        out[p++] = d[i];
        out[p++] = d[i + 3];
      }
    }
    return out;
  }

  function resampleImageData(imgd, W, H) {
    if (imgd.width === W && imgd.height === H) return imgd;
    const src = document.createElement('canvas');
    src.width = imgd.width;
    src.height = imgd.height;
    src.getContext('2d').putImageData(imgd, 0, 0);
    const dst = document.createElement('canvas');
    dst.width = W;
    dst.height = H;
    const dx = dst.getContext('2d');
    dx.imageSmoothingEnabled = false;
    dx.drawImage(src, 0, 0, imgd.width, imgd.height, 0, 0, W, H);
    return dx.getImageData(0, 0, W, H);
  }

  function renderForMode(imgd, mode, grayscale) {
    const out = new ImageData(imgd.width, imgd.height);
    const S = imgd.data, R = out.data;
    const tint = { r: [255, 0, 0], g: [0, 255, 0], b: [0, 0, 255], a: [168, 85, 247] };
    for (let i = 0; i < S.length; i += 4) {
      const r = S[i], g = S[i + 1], b = S[i + 2], a = S[i + 3];
      if (mode === 'rgba') {
        R[i] = r;
        R[i + 1] = g;
        R[i + 2] = b;
        R[i + 3] = 255;
        continue;
      }
      const ch = mode;
      const v = ch === 'r' ? r : ch === 'g' ? g : ch === 'b' ? b : a;
      if (grayscale) {
        R[i] = R[i + 1] = R[i + 2] = v;
        R[i + 3] = 255;
      } else {
        const t = tint[ch];
        R[i] = Math.round(v * t[0] / 255);
        R[i + 1] = Math.round(v * t[1] / 255);
        R[i + 2] = Math.round(v * t[2] / 255);
        R[i + 3] = 255;
      }
    }
    return out;
  }

  function drawInto(canvas, imgd) {
    canvas.width = imgd.width;
    canvas.height = imgd.height;
    canvas.getContext('2d').putImageData(imgd, 0, 0);
  }

  return {
    parseTGA,
    encodeTGA,
    resampleImageData,
    renderForMode,
    drawInto
  };
})();

/***********************
 * Curves Editor Module  *
 ***********************/
MERS.CurvesEditor = (function() {
  'use strict';
  
  const { lerp } = MERS.Utils;

  function evalCurveAt(key, x01) {
    const state = MERS.StateManager.getState();
    const pts = state.curves[key];
    const X = x01 * 520;
    let i = 0;
    while (i < pts.length - 1 && X > pts[i + 1].x) i++;
    const p1 = pts[i], p2 = pts[Math.min(i + 1, pts.length - 1)];
    if (p2.x === p1.x) return 1 - (p1.y / 160);
    const t = (X - p1.x) / (p2.x - p1.x);
    const y = lerp(p1.y, p2.y, t);
    return 1 - (y / 160);
  }

  function bindCurve(canvas, key) {
    const ctx = canvas.getContext('2d');
    const radius = 6;
    let dragPoint = null;
    let dragIdx = -1;

    function draw() {
      const state = MERS.StateManager.getState();
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      // grid
      ctx.strokeStyle = '#2a2d4b';
      ctx.lineWidth = 1;
      ctx.beginPath();
      for (let i = 1; i < 8; i++) {
        const x = i * canvas.width / 8;
        ctx.moveTo(x, 0);
        ctx.lineTo(x, canvas.height);
        const y = i * canvas.height / 8;
        ctx.moveTo(0, y);
        ctx.lineTo(canvas.width, y);
      }
      ctx.stroke();
      // diagonal
      ctx.strokeStyle = '#3b3f67';
      ctx.setLineDash([6, 6]);
      ctx.beginPath();
      ctx.moveTo(0, canvas.height);
      ctx.lineTo(canvas.width, 0);
      ctx.stroke();
      ctx.setLineDash([]);
      // polyline
      const pts = state.curves[key];
      ctx.strokeStyle = { r: '#ef4444', g: '#10b981', b: '#3b82f6', a: '#a855f7' }[key];
      ctx.lineWidth = 2.5;
      ctx.beginPath();
      ctx.moveTo(pts[0].x, pts[0].y);
      for (let i = 1; i < pts.length; i++) ctx.lineTo(pts[i].x, pts[i].y);
      ctx.stroke();
      // points
      for (const p of pts) {
        ctx.fillStyle = '#0f1120';
        ctx.beginPath();
        ctx.arc(p.x, p.y, radius, 0, Math.PI * 2);
        ctx.fill();
        ctx.strokeStyle = '#fff';
        ctx.lineWidth = 2;
        ctx.stroke();
      }
    }

    function nearestCanvasXY(e) {
      const rect = canvas.getBoundingClientRect();
      const scaleX = canvas.width / rect.width;
      const scaleY = canvas.height / rect.height;
      const x = (e.clientX - rect.left) * scaleX;
      const y = (e.clientY - rect.top) * scaleY;
      return { x, y };
    }

    function nearestIndex(x, y) {
      const state = MERS.StateManager.getState();
      const pts = state.curves[key];
      let i = -1, d = 9999;
      pts.forEach((p, idx) => {
        const dist = Math.hypot(p.x - x, p.y - y);
        if (dist < d && dist < 10) {
          d = dist;
          i = idx;
        }
      });
      return i;
    }

    canvas.addEventListener('contextmenu', e => {
      e.preventDefault();
      const { x, y } = nearestCanvasXY(e);
      const i = nearestIndex(x, y);
      const state = MERS.StateManager.getState();
      if (i > 0 && i < state.curves[key].length - 1) {
        state.curves[key].splice(i, 1);
        draw();
        MERS.Core.recompute();
      }
    });

    canvas.addEventListener('mousedown', e => {
      const { x, y } = nearestCanvasXY(e);
      const i = nearestIndex(x, y);
      const state = MERS.StateManager.getState();
      if (i > -1) {
        dragPoint = state.curves[key][i];
        dragIdx = i;
      } else {
        const p = { x: Math.max(0, Math.min(canvas.width, x)), y: Math.max(0, Math.min(canvas.height, y)) };
        state.curves[key].push(p);
        state.curves[key].sort((a, b) => a.x - b.x);
        dragIdx = state.curves[key].indexOf(p);
        dragPoint = p;
      }
      draw();
    });

    window.addEventListener('mousemove', e => {
      if (!dragPoint) return;
      const { x, y } = nearestCanvasXY(e);
      const state = MERS.StateManager.getState();
      const pts = state.curves[key];
      const prev = pts[dragIdx - 1];
      const next = pts[dragIdx + 1];
      const minX = dragIdx === 0 ? 0 : prev.x + 1;
      const maxX = dragIdx === pts.length - 1 ? canvas.width : next.x - 1;
      dragPoint.x = Math.max(minX, Math.min(maxX, x));
      dragPoint.y = Math.max(0, Math.min(canvas.height, y));
      draw();
      MERS.Core.recompute();
    });

    window.addEventListener('mouseup', () => {
      dragPoint = null;
      dragIdx = -1;
    });

    draw();
  }

  function drawAllCurves() {
    bindCurve(document.getElementById('curveR'), 'r');
    bindCurve(document.getElementById('curveG'), 'g');
    bindCurve(document.getElementById('curveB'), 'b');
    bindCurve(document.getElementById('curveA'), 'a');
  }

  return {
    evalCurveAt,
    bindCurve,
    drawAllCurves
  };
})();

/***********************
 * Paint Tool Module     *
 ***********************/
MERS.PaintTool = (function() {
  'use strict';
  
  function initPaintLayer(w, h) {
    const paintState = MERS.StateManager.getPaintState();
    try {
      paintState.layer = new ImageData(new Uint8ClampedArray(w * h * 4), w, h);
    } catch (e) {
      const arr = new Uint8ClampedArray(w * h * 4);
      paintState.layer = { data: arr, width: w, height: h };
    }
    try {
      paintState.mask = new Uint8Array(w * h);
      paintState.selection = new Uint8Array(w * h);
    } catch (e) {
      paintState.mask = new Array(w * h).fill(0);
      paintState.selection = new Array(w * h).fill(0);
    }
  }

  function applyPaintOnOut() {
    const state = MERS.StateManager.getState();
    const paintState = MERS.StateManager.getPaintState();
    if (!state.out || !paintState.layer || !paintState.mask) return;
    const outD = state.out.data;
    const layD = paintState.layer.data;
    const mask = paintState.mask;
    const w = state.out.width, h = state.out.height;
    for (let p = 0; p < w * h; p++) {
      const m = mask[p];
      if (!m) continue;
      const i = p * 4;
      if (m & 1) outD[i + 0] = layD[i + 0];
      if (m & 2) outD[i + 1] = layD[i + 1];
      if (m & 4) outD[i + 2] = layD[i + 2];
      if (m & 8) outD[i + 3] = layD[i + 3];
    }
  }

  function saveHistory() {
  const state = MERS.StateManager.getState();
  const ps = MERS.StateManager.getPaintState();
  if (!state.out) return;

  // Prefer dual-layer fields if present; fall back to legacy
  const brushLayer = ps.layerBrush || ps.layer || null;
  const bucketLayer = ps.layerBucket || null;
  const maskBrush = ps.maskBrush || ps.mask || null;
  const maskBucket = ps.maskBucket || null;

  ps.undoStack.push({
    outData: state.out.data.slice(),
    brush: brushLayer ? brushLayer.data.slice() : null,
    bucket: bucketLayer ? bucketLayer.data.slice() : null,
    maskBrush: maskBrush ? maskBrush.slice() : null,
    maskBucket: maskBucket ? maskBucket.slice() : null
  });
  ps.redoStack.length = 0;
  updateUndoRedoButtons();
}

  function updateUndoRedoButtons() {
    const paintState = MERS.StateManager.getPaintState();
    const undoBtn = document.getElementById('undoPaint');
    const redoBtn = document.getElementById('redoPaint');
    if (undoBtn) undoBtn.disabled = paintState.undoStack.length === 0;
    if (redoBtn) redoBtn.disabled = paintState.redoStack.length === 0;
  }

  function mapEventToOutImage(e) {
    const state = MERS.StateManager.getState();
    if (!state.out) return null;
    const outCanvas = document.getElementById('canvasOut');
    const rect = outCanvas.getBoundingClientRect();
    const xCanvas = e.clientX - rect.left;
    const yCanvas = e.clientY - rect.top;
    const w = state.out.width;
    const h = state.out.height;
    const frameW = state.anim.w || w;
    const frameH = state.anim.h || h;
    const frames = Math.max(1, Math.floor(h / frameH));
    const frameY = state.anim.on ? state.anim.i * frameH : Math.min(state.anim.i, frames - 1) * frameH;
    const viewW = Math.min(frameW, w);
    const viewH = Math.min(frameH, h - frameY);
    const fit = Math.min(rect.width / viewW, rect.height / viewH);
    const scale = fit * state.zoom;
    const dx = Math.round((rect.width - viewW * scale) / 2 + state.panX);
    const dy = Math.round((rect.height - viewH * scale) / 2 + state.panY);
    const ix = (xCanvas - dx) / scale;
    const iy = (yCanvas - dy) / scale;
    const xImg = Math.floor(ix + 1e-9);
    const yImg = Math.floor(iy + 1e-9) + frameY;
    if (isNaN(xImg) || isNaN(yImg)) return null;
    if (xImg < 0 || xImg >= w || yImg < 0 || yImg >= h) return null;
    return { x: xImg, y: yImg };
  }

  function activeChannel() {
    const state = MERS.StateManager.getState();
    const m = state.mode;
    return (m === 'r' || m === 'g' || m === 'b' || m === 'a') ? m : null;
  }

  function chInfo(ch) {
    return ch === 'r' ? { off: 0, bit: 1 } :
           ch === 'g' ? { off: 1, bit: 2 } :
           ch === 'b' ? { off: 2, bit: 4 } :
           ch === 'a' ? { off: 3, bit: 8 } : null;
  }

  function paintAt(e) {
    const state = MERS.StateManager.getState();
    const paintState = MERS.StateManager.getPaintState();
    if (!paintState.layer || !state.out) return;
    const ch = activeChannel();
    if (!ch) return;
    const { off, bit } = chInfo(ch);

    const coord = mapEventToOutImage(e);
    if (!coord) return;
    const w = paintState.layer.width;
    const h = paintState.layer.height;
    const size = paintState.size;
    const px = coord.x;
    const py = coord.y;
    const col = [paintState.color.r, paintState.color.g, paintState.color.b, paintState.color.a][off];

    for (let dy = 0; dy < size; dy++) {
      const y = py + dy;
      if (y < 0 || y >= h) continue;
      for (let dx = 0; dx < size; dx++) {
        const x = px + dx;
        if (x < 0 || x >= w) continue;
        const idx = (y * w + x) * 4;
        const p = (y * w + x);
        paintState.layer.data[idx + off] = col;
        paintState.mask[p] = (paintState.mask[p] | bit);
        state.out.data[idx + off] = paintState.layer.data[idx + off];
      }
    }
    MERS.PreviewManager.drawPreview();
  }

  function bucketFillAt(e) {
    const state = MERS.StateManager.getState();
    const paintState = MERS.StateManager.getPaintState();
    if (!state.out || !paintState.layer) return;
    const ch = activeChannel();
    if (!ch) return;
    const { off, bit } = chInfo(ch);

    const coord = mapEventToOutImage(e);
    if (!coord) return;
    const w = state.out.width, h = state.out.height;
    const data = state.out.data;
    const layer = paintState.layer.data;
    const idx0 = (coord.y * w + coord.x) * 4;
    const targetV = data[idx0 + off];
    const newV = [paintState.color.r, paintState.color.g, paintState.color.b, paintState.color.a][off];
    if (targetV === newV) return;

    const seen = new Uint8Array(w * h);
    const stack = [idx0];
    seen[(idx0 / 4) | 0] = 1;
    const pushIfMatch = (i) => {
      const p = (i / 4) | 0;
      if (seen[p]) return;
      if (data[i + off] === targetV) {
        seen[p] = 1;
        stack.push(i);
      }
    };

    while (stack.length) {
      const i = stack.pop();
      const p = (i / 4) | 0;
      data[i + off] = newV;
      layer[i + off] = newV;
      paintState.mask[p] = (paintState.mask[p] | bit);
      const x = p % w, y = (p / w) | 0;
      if (x > 0) pushIfMatch(i - 4);
      if (x < w - 1) pushIfMatch(i + 4);
      if (y > 0) pushIfMatch(i - 4 * w);
      if (y < h - 1) pushIfMatch(i + 4 * w);
    }
    MERS.PreviewManager.drawPreview();
    MERS.HistogramManager.drawHistogram();
  }

  function pickColorFromEvent(e, imgType) {
    const state = MERS.StateManager.getState();
    const paintState = MERS.StateManager.getPaintState();
    let imgd = null, canvas = null;
    if (imgType === 'ref' && state.ref) {
      imgd = state.ref;
      canvas = document.getElementById('canvasRef');
    } else if (imgType === 'src' && state.src) {
      imgd = state.src;
      canvas = document.getElementById('canvasSrc');
    } else if (imgType === 'out' && state.out) {
      imgd = state.out;
      canvas = document.getElementById('canvasOut');
    }
    if (!imgd || !canvas) return;

    const rect = canvas.getBoundingClientRect();
    const xCanvas = e.clientX - rect.left;
    const yCanvas = e.clientY - rect.top;

    const w = imgd.width, h = imgd.height;
    let viewW, viewH, frameY;

    if (imgType === 'ref' || imgType === 'out') {
      const frameW = state.anim.w || w;
      const frameH = state.anim.h || h;
      const frames = Math.max(1, Math.floor(h / frameH));
      frameY = state.anim.on ? state.anim.i * frameH : Math.min(state.anim.i, frames - 1) * frameH;
      viewW = Math.min(frameW, w);
      viewH = Math.min(frameH, h - frameY);

      const fit = Math.min(rect.width / viewW, rect.height / viewH);
      const scale = fit * state.zoom;
      const dx = Math.round((rect.width - viewW * scale) / 2 + state.panX);
      const dy = Math.round((rect.height - viewH * scale) / 2 + state.panY);

      const ix = (xCanvas - dx) / scale;
      const iy = (yCanvas - dy) / scale;

      var xImg = Math.floor(ix + 1e-9);
      var yImg = Math.floor(iy + 1e-9) + frameY;
    } else {
      const scaleX = w / rect.width;
      const scaleY = h / rect.height;
      var xImg = Math.floor(xCanvas * scaleX + 1e-9);
      var yImg = Math.floor(yCanvas * scaleY + 1e-9);
    }

    if (xImg < 0 || xImg >= w || yImg < 0 || yImg >= h) return;

    const idx = (yImg * w + xImg) * 4, data = imgd.data;
    const r = data[idx], g = data[idx + 1], b = data[idx + 2], a = data[idx + 3];

    // Determine which channel is currently active.
    // In RGBA mode we don't modify the colour at all – a click should do nothing.
    const mode = state && state.mode;
    if (!paintState || !mode || mode === 'rgba') {
      return;
    }

    // Prepare new colour object. When selecting a single channel (r/g/b), we
    // explicitly zero out the other colour channels so the brush swatch
    // represents only the picked channel. Alpha is handled separately.
    let newColor;
    const getAlpha = () => (paintState.copyAlpha ? a : 255);
    switch (mode) {
      case 'r':
        newColor = { r: r, g: 0, b: 0, a: getAlpha() };
        break;
      case 'g':
        newColor = { r: 0, g: g, b: 0, a: getAlpha() };
        break;
      case 'b':
        newColor = { r: 0, g: 0, b: b, a: getAlpha() };
        break;
      case 'a':
        // For alpha channel, colour components are zero and only alpha is set
        newColor = { r: 0, g: 0, b: 0, a: getAlpha() };
        break;
      default:
        return;
    }
    paintState.color = newColor;

    // Update the colour input swatch (r, g, b) to reflect the new colour.
    const colorInput = document.getElementById('brushColor');
    if (colorInput) {
      const toHex = v => ('0' + Math.max(0, Math.min(255, v)).toString(16)).slice(-2);
      colorInput.value = '#' + toHex(newColor.r) + toHex(newColor.g) + toHex(newColor.b);
    }
  }

  function selectByColor(e) {
    const state = MERS.StateManager.getState();
    const paintState = MERS.StateManager.getPaintState();
    if (!state.out || !paintState.selection) return;
    
    const ch = activeChannel();
    if (!ch) return; // Only works with single channel selected
    
    const { off } = chInfo(ch);
    const coord = mapEventToOutImage(e);
    if (!coord) return;
    
    const w = state.out.width, h = state.out.height;
    const data = state.out.data;
    const targetIdx = (coord.y * w + coord.x) * 4;
    const targetValue = data[targetIdx + off];
    
    // Clear previous selection unless Shift is held (additive multi-select)
    if (!(e && e.shiftKey)) paintState.selection.fill(0);
    
    // Select all pixels with the same value in this channel
    for (let y = 0; y < h; y++) {
      for (let x = 0; x < w; x++) {
        const idx = (y * w + x) * 4;
        const p = y * w + x;
        if (data[idx + off] === targetValue) {
          paintState.selection[p] = 1;
        }
      }
    }
    
    drawSelectionOverlay();
    updateSelectionButtons();
  }

  function fillSelection() {
    const state = MERS.StateManager.getState();
    const paintState = MERS.StateManager.getPaintState();
    if (!state.out || !paintState.layer || !paintState.selection) return;
    
    const ch = activeChannel();
    if (!ch) return;
    
    const { off, bit } = chInfo(ch);
    const w = state.out.width, h = state.out.height;
    const data = state.out.data;
    const layer = paintState.layer.data;
    const newV = [paintState.color.r, paintState.color.g, paintState.color.b, paintState.color.a][off];
    
    saveHistory();
    
    for (let p = 0; p < w * h; p++) {
      if (paintState.selection[p]) {
        const i = p * 4;
        data[i + off] = newV;
        layer[i + off] = newV;
        paintState.mask[p] = (paintState.mask[p] | bit);
      }
    }
    
    MERS.PreviewManager.drawPreview();
    MERS.HistogramManager.drawHistogram();
  }

  function clearSelection() {
    const paintState = MERS.StateManager.getPaintState();
    if (!paintState.selection) return;
    
    paintState.selection.fill(0);
    drawSelectionOverlay();
    updateSelectionButtons();
  }

  function drawSelectionOverlay() {
    const state = MERS.StateManager.getState();
    const paintState = MERS.StateManager.getPaintState();
    const canvas = document.getElementById('canvasSelection');
    if (!canvas || !state.out || !paintState.selection) return;

    // Helper to position and size an overlay canvas to match its underlying preview canvas.
    function syncOverlayCanvas(overlay, targetCanvas) {
      const wrap = targetCanvas.parentNode;
      const rect = targetCanvas.getBoundingClientRect();
      const wrapRect = wrap.getBoundingClientRect();
      const topOffset = rect.top - wrapRect.top;
      const leftOffset = rect.left - wrapRect.left;
      overlay.style.top = `${topOffset}px`;
      overlay.style.left = `${leftOffset}px`;
      overlay.style.width = `${rect.width}px`;
      overlay.style.height = `${rect.height}px`;
      const wcss = Math.round(rect.width);
      const hcss = Math.round(rect.height);
      if (overlay.width !== wcss || overlay.height !== hcss) {
        overlay.width = wcss;
        overlay.height = hcss;
      }
    }

    // Determine whether there is any selected pixel before drawing
    let hasSelection = false;
    for (let i = 0; i < paintState.selection.length; i++) {
      if (paintState.selection[i]) {
        hasSelection = true;
        break;
      }
    }
    if (!hasSelection) {
      // Clear both overlays and bail early when nothing is selected
      const ctxOutSel = canvas.getContext('2d');
      ctxOutSel.clearRect(0, 0, canvas.width, canvas.height);
      const canvasRefSel = document.getElementById('canvasSelectionRef');
      if (canvasRefSel) {
        const ctxRefSel = canvasRefSel.getContext('2d');
        ctxRefSel.clearRect(0, 0, canvasRefSel.width, canvasRefSel.height);
      }
      return;
    }

    // Draw overlay on the output (left) preview
    {
      const outCanvas = document.getElementById('canvasOut');
      const ctx = canvas.getContext('2d');
      // Match CSS positioning and size to the output preview canvas
      syncOverlayCanvas(canvas, outCanvas);
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      const w = state.out.width;
      const h = state.out.height;
      const frameW = state.anim.w || w;
      const frameH = state.anim.h || h;
      const frames = Math.max(1, Math.floor(h / frameH));
      const frameY = state.anim.on ? state.anim.i * frameH : Math.min(state.anim.i, frames - 1) * frameH;
      const viewW = Math.min(frameW, w);
      const viewH = Math.min(frameH, h - frameY);
      const fit = Math.min(canvas.width / viewW, canvas.height / viewH);
      const scale = fit * state.zoom;
      const dx = (canvas.width - viewW * scale) / 2 + state.panX;
      const dy = (canvas.height - viewH * scale) / 2 + state.panY;
      ctx.save();
      ctx.setTransform(scale, 0, 0, scale, dx, dy);
      ctx.imageSmoothingEnabled = false;
      const time = Date.now() / 2000;
      ctx.strokeStyle = '#ffffff';
      ctx.lineWidth = 1 / scale;
      ctx.setLineDash([4 / scale, 4 / scale]);
      ctx.lineDashOffset = -time % (8 / scale);
      ctx.beginPath();
      for (let sy = 0; sy < viewH; sy++) {
        const y = sy + frameY;
        for (let x = 0; x < viewW; x++) {
          const p = y * w + x;
          if (!paintState.selection[p]) continue;
          // left edge
          if (x === 0 || !paintState.selection[p - 1]) {
            ctx.moveTo(x, sy);
            ctx.lineTo(x, sy + 1);
          }
          // right edge
          if (x === viewW - 1 || !paintState.selection[p + 1]) {
            ctx.moveTo(x + 1, sy);
            ctx.lineTo(x + 1, sy + 1);
          }
          // top edge
          if (sy === 0 || !paintState.selection[p - w]) {
            ctx.moveTo(x, sy);
            ctx.lineTo(x + 1, sy);
          }
          // bottom edge
          if (sy === viewH - 1 || !paintState.selection[p + w]) {
            ctx.moveTo(x, sy + 1);
            ctx.lineTo(x + 1, sy + 1);
          }
        }
      }
      ctx.stroke();
      ctx.restore();
    }

    // Draw overlay on the reference (right) preview if a reference is loaded
    const canvasRefSel = document.getElementById('canvasSelectionRef');
    const refCanvas = document.getElementById('canvasRef');
    if (canvasRefSel && refCanvas && state.ref) {
      const ctxR = canvasRefSel.getContext('2d');
      // Sync overlay position/size with the reference preview canvas
      syncOverlayCanvas(canvasRefSel, refCanvas);
      ctxR.clearRect(0, 0, canvasRefSel.width, canvasRefSel.height);
      const rw = state.ref.width;
      const rh = state.ref.height;
      const frameW = state.anim.w || rw;
      const frameH = state.anim.h || rh;
      const framesR = Math.max(1, Math.floor(rh / frameH));
      const frameYRef = state.anim.on ? state.anim.i * frameH : Math.min(state.anim.i, framesR - 1) * frameH;
      const viewW = Math.min(frameW, rw);
      const viewH = Math.min(frameH, rh - frameYRef);
      const fitR = Math.min(canvasRefSel.width / viewW, canvasRefSel.height / viewH);
      const scaleR = fitR * state.zoom;
      const dxR = (canvasRefSel.width - viewW * scaleR) / 2 + state.panX;
      const dyR = (canvasRefSel.height - viewH * scaleR) / 2 + state.panY;
      ctxR.save();
      ctxR.setTransform(scaleR, 0, 0, scaleR, dxR, dyR);
      ctxR.imageSmoothingEnabled = false;
      const timeR = Date.now() / 2000;
      ctxR.strokeStyle = '#ffffff';
      ctxR.lineWidth = 1 / scaleR;
      ctxR.setLineDash([4 / scaleR, 4 / scaleR]);
      ctxR.lineDashOffset = -timeR % (8 / scaleR);
      ctxR.beginPath();
      // Use state.out dimensions for selection indexing; selection array length equals w*h of state.out
      const wOut = state.out.width;
      const hOut = state.out.height;
      for (let sy = 0; sy < viewH; sy++) {
        const y = sy + frameYRef;
        for (let x = 0; x < viewW; x++) {
          const p = y * wOut + x;
          if (!paintState.selection[p]) continue;
          // left edge
          if (x === 0 || !paintState.selection[p - 1]) {
            ctxR.moveTo(x, sy);
            ctxR.lineTo(x, sy + 1);
          }
          // right edge
          if (x === viewW - 1 || !paintState.selection[p + 1]) {
            ctxR.moveTo(x + 1, sy);
            ctxR.lineTo(x + 1, sy + 1);
          }
          // top edge
          if (sy === 0 || !paintState.selection[p - wOut]) {
            ctxR.moveTo(x, sy);
            ctxR.lineTo(x + 1, sy);
          }
          // bottom edge
          if (sy === viewH - 1 || !paintState.selection[p + wOut]) {
            ctxR.moveTo(x, sy + 1);
            ctxR.lineTo(x + 1, sy + 1);
          }
        }
      }
      ctxR.stroke();
      ctxR.restore();
    }
  }

  function updateSelectionButtons() {
    const paintState = MERS.StateManager.getPaintState();
    const fillBtn = document.getElementById('fillSelection');
    const clearBtn = document.getElementById('clearSelection');
    
    let hasSelection = false;
    if (paintState.selection) {
      for (let i = 0; i < paintState.selection.length; i++) {
        if (paintState.selection[i]) {
          hasSelection = true;
          break;
        }
      }
    }
    
    if (fillBtn) fillBtn.disabled = !hasSelection;
    if (clearBtn) clearBtn.disabled = !hasSelection;
  }

  return {
    initPaintLayer,
    applyPaintOnOut,
    saveHistory,
    updateUndoRedoButtons,
    mapEventToOutImage,
    activeChannel,
    chInfo,
    paintAt,
    bucketFillAt,
    pickColorFromEvent,
    selectByColor,
    fillSelection,
    clearSelection,
    drawSelectionOverlay,
    updateSelectionButtons
  };
})();

/***********************
 * File Manager Module   *
 ***********************/
MERS.FileManager = (function() {
  'use strict';
  
  const { $ } = MERS.Utils;

  function loadTexture(file) {
    const nameSpan = $('#texName');
    nameSpan.textContent = file.name;
    const reader = new FileReader();
    
    if (file.name.toLowerCase().endsWith('.png')) {
      reader.onload = () => {
        const img = new Image();
        img.onload = () => {
          const c = document.createElement('canvas');
          c.width = img.width;
          c.height = img.height;
          c.getContext('2d').drawImage(img, 0, 0);
          const state = MERS.StateManager.getState();
          state.src = c.getContext('2d').getImageData(0, 0, c.width, c.height);
          MERS.ImageProcessor.drawInto($('#canvasSrc'), state.src);
          $('#srcInfo').textContent = `${c.width}×${c.height}`;
          $('#dimInfo').textContent = `${c.width}×${c.height}`;
          
          MERS.PaintTool.initPaintLayer(c.width, c.height);
          
          state.anim.w = c.width;
          state.anim.h = c.width;
          MERS.AnimationManager.updateFrameControls(c.width, c.height);
          MERS.Core.rebuildRefColorMap();
          MERS.Core.recompute();
          // Apply default zoom after loading a texture so it fits nicely within the preview.
          {
            const st = MERS.StateManager.getState();
            st.zoom = 0.87;
            const zoomLabel = document.getElementById('zoomVal');
            if (zoomLabel) zoomLabel.textContent = Math.round(st.zoom * 100) + '%';
          }
        };
        img.src = reader.result;
      };
      reader.readAsDataURL(file);
    } else {
      reader.onload = () => {
        const state = MERS.StateManager.getState();
        state.src = MERS.ImageProcessor.parseTGA(new DataView(reader.result));
        MERS.ImageProcessor.drawInto($('#canvasSrc'), state.src);
        $('#srcInfo').textContent = `${state.src.width}×${state.src.height}`;
        $('#dimInfo').textContent = `${state.src.width}×${state.src.height}`;
        
        MERS.PaintTool.initPaintLayer(state.src.width, state.src.height);
        
        state.anim.w = state.src.width;
        state.anim.h = state.src.width;
        MERS.AnimationManager.updateFrameControls(state.src.width, state.src.height);
        MERS.Core.rebuildRefColorMap();
        MERS.Core.recompute();
        // Apply default zoom after loading a texture so it fits nicely within the preview.
        {
          const st = MERS.StateManager.getState();
          st.zoom = 0.87;
          const zoomLabel = document.getElementById('zoomVal');
          if (zoomLabel) zoomLabel.textContent = Math.round(st.zoom * 100) + '%';
        }
      };
      reader.readAsArrayBuffer(file);
    }
  }

  function loadReference(file) {
    const nameSpan = $('#refName');
    nameSpan.textContent = file.name;
    const reader = new FileReader();
    reader.onload = () => {
      const ref = MERS.ImageProcessor.parseTGA(new DataView(reader.result));
      const state = MERS.StateManager.getState();
      state.ref = ref;
      MERS.PreviewManager.drawReference();
      MERS.UIManager.updateRefControls();
      MERS.Core.rebuildRefColorMap();
    };
    reader.readAsArrayBuffer(file);
  }

  return {
    loadTexture,
    loadReference
  };
})();

/***********************
 * Preview Manager Module *
 ***********************/
MERS.PreviewManager = (function() {
  'use strict';
  
  function drawReference() {
    const state = MERS.StateManager.getState();
    if (!state.ref) return;
    const info = document.getElementById('refInfo');
    if (info) info.textContent = `${state.ref.width}×${state.ref.height}`;
    const cr = document.getElementById('canvasRef');
    if (cr) {
      const rectR = cr.getBoundingClientRect();
      const wcssR = Math.round(rectR.width);
      const hcssR = Math.round(rectR.height);
      if (cr.width !== wcssR || cr.height !== hcssR) {
        cr.width = wcssR;
        cr.height = hcssR;
      }
      const cx = cr.getContext('2d');
      cx.imageSmoothingEnabled = false;
      cx.setTransform(1, 0, 0, 1, 0, 0);
      cx.clearRect(0, 0, cr.width, cr.height);
    }
    drawPreview();
  }

  function drawPreview() {
    const state = MERS.StateManager.getState();
    const canvasOut = document.getElementById('canvasOut');
    const ctxOut = canvasOut.getContext('2d');
    
    ctxOut.save();
    ctxOut.imageSmoothingEnabled = false;
    ctxOut.setTransform(1, 0, 0, 1, 0, 0);
    ctxOut.clearRect(0, 0, canvasOut.width, canvasOut.height);
    ctxOut.fillStyle = '#0b0d1f';
    
    const rect = canvasOut.getBoundingClientRect();
    const wcss = Math.round(rect.width);
    const hcss = Math.round(rect.height);
    if (canvasOut.width !== wcss || canvasOut.height !== hcss) {
      canvasOut.width = wcss;
      canvasOut.height = hcss;
    }
    ctxOut.fillRect(0, 0, canvasOut.width, canvasOut.height);
    ctxOut.restore();
    
    if (!state.out) return;
    
    const w = state.out.width, h = state.out.height;
    const frameW = state.anim.w || w, frameH = state.anim.h || h;
    const frames = Math.max(1, Math.floor(h / frameH));
    const frameY = state.anim.on ? state.anim.i * frameH : Math.min(state.anim.i, frames - 1) * frameH;
    const off = document.createElement('canvas');
    off.width = w;
    off.height = h;
    off.getContext('2d').putImageData(MERS.ImageProcessor.renderForMode(state.out, state.mode, state.grayscale), 0, 0);
    const view = { x: 0, y: frameY, w: Math.min(frameW, w), h: Math.min(frameH, h - frameY) };
    const fit = Math.min(canvasOut.width / view.w, canvasOut.height / view.h);
    const scale = fit * state.zoom;
    const dx = Math.round((canvasOut.width - view.w * scale) / 2 + state.panX);
    const dy = Math.round((canvasOut.height - view.h * scale) / 2 + state.panY);
    ctxOut.save();
    ctxOut.setTransform(scale, 0, 0, scale, dx, dy);
    ctxOut.imageSmoothingEnabled = false;
    ctxOut.drawImage(off, view.x, view.y, view.w, view.h, 0, 0, view.w, view.h);
    ctxOut.restore();
    
    // REF canvas
    if (state.ref) {
      const cr = document.getElementById('canvasRef');
      const cx = cr.getContext('2d');
      const rectR = cr.getBoundingClientRect();
      const wcssR = Math.round(rectR.width);
      const hcssR = Math.round(rectR.height);
      if (cr.width !== wcssR || cr.height !== hcssR) {
        cr.width = wcssR;
        cr.height = hcssR;
      }
      
      cx.save();
      cx.setTransform(1, 0, 0, 1, 0, 0);
      cx.clearRect(0, 0, cr.width, cr.height);
      const rw = state.ref.width, rh = state.ref.height;
      const tmp = document.createElement('canvas');
      tmp.width = rw;
      tmp.height = rh;
      tmp.getContext('2d').putImageData(MERS.ImageProcessor.renderForMode(state.ref, state.mode, state.grayscale), 0, 0);
      const viewW = Math.min(frameW, rw);
      const viewH = Math.min(frameH, rh);
      const frameYRef = Math.min(Math.max(frameY, 0), Math.max(0, rh - viewH));
      const fitR = Math.min(cr.width / viewW, cr.height / viewH);
      const scaleR = fitR * state.zoom;
      const dxR = Math.round((cr.width - viewW * scaleR) / 2 + state.panX);
      const dyR = Math.round((cr.height - viewH * scaleR) / 2 + state.panY);
      cx.setTransform(scaleR, 0, 0, scaleR, dxR, dyR);
      cx.drawImage(tmp, 0, frameYRef, viewW, viewH, 0, 0, viewW, viewH);
      cx.restore();
    }
  }

  return {
    drawReference,
    drawPreview
  };
})();

/***********************
 * Histogram Manager Module *
 ***********************/
MERS.HistogramManager = (function() {
  'use strict';
  
  function drawHistogram() {
    const state = MERS.StateManager.getState();
    const histWin = document.getElementById('histWin');
    const histCanvas = document.getElementById('histCanvas');
    
    if (histWin.style.display !== 'flex' || !state.out) return;
    
    const hctx = histCanvas.getContext('2d');
    const img = state.out.data;
    const binsR = new Uint32Array(256), binsG = new Uint32Array(256), binsB = new Uint32Array(256), binsA = new Uint32Array(256);
    
    for (let i = 0; i < img.length; i += 4) {
      binsR[img[i]]++;
      binsG[img[i + 1]]++;
      binsB[img[i + 2]]++;
      binsA[img[i + 3]]++;
    }
    
    const H = histCanvas.height, W = histCanvas.width;
    hctx.clearRect(0, 0, W, H);
    const max = Math.max(...binsR, ...binsG, ...binsB, ...binsA);
    
    function plot(bins, color) {
      hctx.beginPath();
      hctx.strokeStyle = color;
      hctx.lineWidth = 1.5;
      for (let x = 0; x < 256; x++) {
        const y = H - (bins[x] / max) * H;
        if (x === 0) hctx.moveTo(x * (W / 256), y);
        else hctx.lineTo(x * (W / 256), y);
      }
      hctx.stroke();
    }
    
    plot(binsR, '#ef4444');
    plot(binsG, '#10b981');
    plot(binsB, '#3b82f6');
    plot(binsA, '#a855f7');
    hctx.fillStyle = '#8b5cf6';
    hctx.fillText('R G B A', 6, 12);
  }

  function makeHistogramDraggable() {
    const histWin = document.getElementById('histWin');
    const drag = document.getElementById('histDrag');
    let sx = 0, sy = 0, dragging = false;
    
    drag.addEventListener('mousedown', e => {
      dragging = true;
      sx = e.clientX - histWin.offsetLeft;
      sy = e.clientY - histWin.offsetTop;
      histWin.classList.add('dragging');
    });
    
    window.addEventListener('mouseup', () => {
      dragging = false;
      histWin.classList.remove('dragging');
    });
    
    window.addEventListener('mousemove', e => {
      if (!dragging) return;
      histWin.style.left = (e.clientX - sx) + 'px';
      histWin.style.top = (e.clientY - sy) + 'px';
    });
  }

  return {
    drawHistogram,
    makeHistogramDraggable
  };
})();

/***********************
 * Animation Manager Module *
 ***********************/
MERS.AnimationManager = (function() {
  'use strict';
  
  function bindAnimSlider(id, key, fmt = '') {
    const { $ } = MERS.Utils;
    const el = $(id), v = $(id + 'V');
    const num = $(id + 'n');
    
    function apply(val) {
      const state = MERS.StateManager.getState();
      const n = Number(val);
      if (Number.isFinite(n)) state.anim[key] = n;
      if (el) el.value = state.anim[key];
      if (v) v.textContent = state.anim[key] + fmt;
      if (num) num.value = state.anim[key];
      if (key === 'w' || key === 'h') MERS.Core.recompute();
      if (key === 'ms' && state.anim.on) setupAnim();
    }
    
    if (el) el.addEventListener('input', () => apply(el.value));
    if (num) num.addEventListener('input', () => apply(num.value));
    apply(el ? el.value : (num ? num.value : state.anim[key]));
  }

  function setupAnim() {
    const state = MERS.StateManager.getState();
    if (state.anim.timer) {
      clearInterval(state.anim.timer);
      state.anim.timer = null;
    }
    if (!state.anim.on) return;
    state.anim.timer = setInterval(() => {
      if (!state.src) return;
      const frames = Math.floor(state.src.height / state.anim.h);
      state.anim.i = (state.anim.i + 1) % Math.max(1, frames);
      const frameIndex = document.getElementById('frameIndex');
      if (frameIndex) frameIndex.value = state.anim.i;
      MERS.PreviewManager.drawPreview();
    }, state.anim.ms);
  }

  function updateFrameControls(width, height) {
    const fw = document.getElementById('frameW'), fh = document.getElementById('frameH');
    const fwv = document.getElementById('frameWV'), fhv = document.getElementById('frameHV');
    const state = MERS.StateManager.getState();
    
    if (fw) {
      fw.max = Math.max(Number(fw.max) || 0, width);
      fw.value = state.anim.w;
      fwv.textContent = state.anim.w;
      const fwn = document.getElementById('frameWn');
      if (fwn) {
        fwn.max = fw.max;
        fwn.value = state.anim.w;
      }
    }
    if (fh) {
      fh.max = Math.max(Number(fh.max) || 0, height);
      fh.value = state.anim.h;
      fhv.textContent = state.anim.h;
      const fhn = document.getElementById('frameHn');
      if (fhn) {
        fhn.max = fh.max;
        fhn.value = state.anim.h;
      }
    }
  }

  return {
    bindAnimSlider,
    setupAnim,
    updateFrameControls
  };
})();

/***********************
 * Export Manager Module *
 ***********************/
MERS.ExportManager = (function() {
  'use strict';
  
  function exportTGA() {
    const state = MERS.StateManager.getState();
    if (!state.out) return;
    const data = MERS.ImageProcessor.encodeTGA(state.out);
    const blob = new Blob([data], { type: 'application/octet-stream' });
    const a = document.createElement('a');
    a.href = URL.createObjectURL(blob);
    const name = (document.getElementById('texName').textContent || 'texture').replace(/\.(png|tga)$/i, '');
    a.download = name + '_mers.tga';
    a.click();
    URL.revokeObjectURL(a.href);
  }

  async function exportZIP() {
    const state = MERS.StateManager.getState();
    if (!state.out) return;
    
    const zip = new JSZip();
    
    function toPNG(ch) {
      const W = state.out.width, H = state.out.height;
      const c = document.createElement('canvas');
      c.width = W;
      c.height = H;
      const ctx = c.getContext('2d');
      const id = ctx.createImageData(W, H);
      const S = state.out.data, R = id.data;
      for (let i = 0; i < S.length; i += 4) {
        const v = ch === 'r' ? S[i] : ch === 'g' ? S[i + 1] : ch === 'b' ? S[i + 2] : S[i + 3];
        R[i] = R[i + 1] = R[i + 2] = v;
        R[i + 3] = 255;
      }
      ctx.putImageData(id, 0, 0);
      return new Promise(res => c.toBlob(b => res(b), 'image/png'));
    }
    
    const files = [['r', 'Red (metalness)'], ['g', 'Green (emissive)'], ['b', 'Blue (roughness)'], ['a', 'Alpha (subsurface)']];
    for (const [ch, name] of files) {
      const blob = await toPNG(ch);
      zip.file(`${name}.png`, blob);
    }
    
    const tgaBlob = new Blob([MERS.ImageProcessor.encodeTGA(state.out)], { type: 'application/octet-stream' });
    zip.file('mers.tga', tgaBlob);
    const content = await zip.generateAsync({ type: 'blob' });
    const a = document.createElement('a');
    a.href = URL.createObjectURL(content);
    const base = (document.getElementById('texName').textContent || 'texture').replace(/\.(png|tga)$/i, '');
    a.download = base + '_mers.zip';
    a.click();
    URL.revokeObjectURL(a.href);
  }

  return {
    exportTGA,
    exportZIP
  };
})();

/***********************
 * UI Manager Module     *
 ***********************/
MERS.UIManager = (function() {
  'use strict';
  
  const { $ } = MERS.Utils;

  function sliderTemplate(label, id, min, max, val, fmt = '') {
    return `
      <div class="slider-row">
        <label for="${id}">${label}</label>
        <input id="${id}" type="range" min="${min}" max="${max}" value="${val}">
        <span id="${id}V">${val}${fmt}</span>
      </div>`;
  }

  function buildChannelGroup(key, name, color) {
    const state = MERS.StateManager.getState();
    const cont = document.getElementById('group' + key.toUpperCase());
    const s = state.sliders[key];
    cont.innerHTML = `
      <div class="row"><span class="chip" style="border-color:${color};color:${color}">${name}</span>
        <label class="switch"><input id="inv-${key}" type="checkbox" ${s.invert ? 'checked' : ''}> invert</label>
      </div>
      ${sliderTemplate('Base', `${key}-base`, 0, 255, s.base)}
      ${sliderTemplate('Texture influence %', `${key}-infl`, 0, 200, s.infl)}
      ${sliderTemplate('Brightness', `${key}-bright`, -100, 100, s.bright)}
      ${sliderTemplate('Contrast %', `${key}-contrast`, 25, 300, s.contrast)}
    `;

    ['base', 'infl', 'bright', 'contrast'].forEach(k => {
      const el = document.getElementById(`${key}-${k}`);
      const val = document.getElementById(`${key}-${k}V`);
      el.addEventListener('input', () => {
        state.sliders[key][k] = Number(el.value);
        val.textContent = el.value + (k === 'infl' ? '' : '');
        MERS.Core.recompute();
      });
    });
    document.getElementById(`inv-${key}`).addEventListener('change', e => {
      state.sliders[key].invert = e.target.checked;
      MERS.Core.recompute();
    });
  }

  function setMappingOn(v) {
    const state = MERS.StateManager.getState();
    MERS.Core.rebuildRefColorMap();
    state.mappingOn = !!v;
    ['useRefMap', 'useRefMapTop'].forEach(id => {
      const el = document.getElementById(id);
      if (el) el.checked = state.mappingOn;
    });
    MERS.Core.recompute();
  }

  function setGrayscale(v) {
    const state = MERS.StateManager.getState();
    state.grayscale = !!v;
    ['grayscaleMode', 'grayscaleTop'].forEach(id => {
      const el = document.getElementById(id);
      if (el) el.checked = state.grayscale;
    });
    MERS.PreviewManager.drawPreview();
  }

  function updateRefControls() {
    const state = MERS.StateManager.getState();
    ['useRefMap', 'useRefMapTop'].forEach(id => {
      const el = document.getElementById(id);
      if (!el) return;
      el.disabled = !state.ref;
      const label = el.closest('label');
      if (label) {
        label.style.opacity = state.ref ? 1 : 0.5;
      }
    });
    const sels = document.querySelectorAll('.refMatchSel');
    sels.forEach(sel => {
      sel.disabled = !state.ref;
      sel.style.opacity = state.ref ? '1' : '0.5';
      if (state.refMatch) {
        sel.value = state.refMatch;
      }
    });
  }

  function resetView() {
    const state = MERS.StateManager.getState();
    // Reset zoom and pan to sensible defaults.  Rather than using a full 100% scale, default
    // to 87% so the entire texture fits comfortably within the preview area.  The pan
    // offsets are cleared so the view is centered.
    state.zoom = 0.87;
    state.panX = state.panY = 0;
    // Update zoom display label to reflect new default
    const zoomLabel = document.getElementById('zoomVal');
    if (zoomLabel) zoomLabel.textContent = Math.round(state.zoom * 100) + '%';
    MERS.PreviewManager.drawPreview();
  }

  function bindEventListeners() {
    // Channel groups
    ['r', 'g', 'b', 'a'].forEach(ch => {
      const names = { r: 'Red • Metalness', g: 'Green • Emissive', b: 'Blue • Roughness', a: 'Alpha • SSS' };
      const colors = { r: '#ef4444', g: '#10b981', b: '#3b82f6', a: '#a855f7' };
      buildChannelGroup(ch, names[ch], colors[ch]);
    });

    // Reset buttons
    $('#resetSliders').addEventListener('click', () => {
      MERS.StateManager.resetSliders();
      ['r', 'g', 'b', 'a'].forEach(ch => buildChannelGroup(ch, '', ''));
      MERS.Core.recompute();
    });
    $('#resetCurves').addEventListener('click', () => {
      MERS.StateManager.resetCurves();
      MERS.CurvesEditor.drawAllCurves();
      MERS.Core.recompute();
    });

    // File pickers
    $('#pickTex').addEventListener('click', () => $('#fileTex').click());
    $('#pickRef').addEventListener('click', () => $('#fileRef').click());
    $('#fileTex').addEventListener('change', e => {
      if (e.target.files[0]) MERS.FileManager.loadTexture(e.target.files[0]);
    });
    $('#fileRef').addEventListener('change', e => {
      if (e.target.files[0]) MERS.FileManager.loadReference(e.target.files[0]);
    });

    // Toggles
    ['useRefMap', 'useRefMapTop'].forEach(id => {
      const el = document.getElementById(id);
      if (el) el.addEventListener('change', e => setMappingOn(e.target.checked));
    });

    ['refMatchLeft', 'refMatchTop'].forEach(id => {
      const el = document.getElementById(id);
      if (el) {
        el.addEventListener('change', e => {
          const state = MERS.StateManager.getState();
          state.refMatch = e.target.value;
          const sels = document.querySelectorAll('.refMatchSel');
          sels.forEach(sel => { sel.value = state.refMatch; });
          MERS.Core.recompute();
        });
      }
    });

    ['grayscaleMode', 'grayscaleTop'].forEach(id => {
      const el = document.getElementById(id);
      if (el) el.addEventListener('change', e => setGrayscale(e.target.checked));
    });

    $('#invertAll').addEventListener('change', e => {
      const state = MERS.StateManager.getState();
      state.invertAll = e.target.checked;
      MERS.Core.recompute();
    });

    $('#darkToggle').addEventListener('click', () => {
      document.body.classList.toggle('dark');
    });

    // Mode buttons
    [...document.querySelectorAll('.panel .strip .btn')].forEach(b => {
      b.addEventListener('click', () => {
        const state = MERS.StateManager.getState();
        state.mode = b.dataset.mode;
        MERS.PreviewManager.drawPreview();
      });
    });

    // Zoom & pan
    const canvasOut = document.getElementById('canvasOut');
    let isDragging = false, lastX = 0, lastY = 0;

    $('#zoomIn').addEventListener('click', () => {
      const state = MERS.StateManager.getState();
      state.zoom = Math.min(16, state.zoom * 1.25);
      $('#zoomVal').textContent = Math.round(state.zoom * 100) + '%';
      MERS.PreviewManager.drawPreview();
    });

    $('#zoomOut').addEventListener('click', () => {
      const state = MERS.StateManager.getState();
      state.zoom = Math.max(.25, state.zoom / 1.25);
      $('#zoomVal').textContent = Math.round(state.zoom * 100) + '%';
      MERS.PreviewManager.drawPreview();
    });

    $('#zoomReset').addEventListener('click', () => {
      // Reset the view to the default zoom and pan settings.  After resetting, update
      // the zoom display to reflect the current zoom rather than hard‑coding 100%.
      resetView();
      const st = MERS.StateManager.getState();
      $('#zoomVal').textContent = Math.round(st.zoom * 100) + '%';
    });

    canvasOut.addEventListener('wheel', e => {
  e.preventDefault();
  const state = MERS.StateManager.getState();
  const s = Math.sign(e.deltaY);
  state.zoom = Math.max(.25, Math.min(16, state.zoom * (s > 0 ? 0.9 : 1.1)));
  document.getElementById('zoomVal').textContent = Math.round(state.zoom * 100) + '%';
  MERS.PreviewManager.drawPreview();
}, { passive: false });
// Ensure zoom works even when tools are enabled by also listening on the paint overlay
const canvasPaint = document.getElementById('canvasPaint');
if (canvasPaint) {
  canvasPaint.addEventListener('wheel', e => {
    e.preventDefault();
    const state = MERS.StateManager.getState();
    const s = Math.sign(e.deltaY);
    state.zoom = Math.max(.25, Math.min(16, state.zoom * (s > 0 ? 0.9 : 1.1)));
    document.getElementById('zoomVal').textContent = Math.round(state.zoom * 100) + '%';
    MERS.PreviewManager.drawPreview();
  }, { passive: false });
}

canvasOut.addEventListener('mousedown', e => {
      const paintState = MERS.StateManager.getPaintState();
      if (paintState && paintState.enabled) return;
      isDragging = true;
      lastX = e.clientX;
      lastY = e.clientY;
    });

    window.addEventListener('mouseup', () => isDragging = false);

    window.addEventListener('mousemove', e => {
      const paintState = MERS.StateManager.getPaintState();
      if (paintState && paintState.enabled) return;
      if (!isDragging) return;
      const state = MERS.StateManager.getState();
      state.panX += e.clientX - lastX;
      state.panY += e.clientY - lastY;
      lastX = e.clientX;
      lastY = e.clientY;
      MERS.PreviewManager.drawPreview();
    });

    // Noise controls
    ['noiseScale', 'noiseAmp'].forEach(id => {
      const el = document.getElementById(id), v = document.getElementById(id + 'V');
      el.addEventListener('input', () => {
        const state = MERS.StateManager.getState();
        const key = id === 'noiseScale' ? 'scale' : 'amp';
        state.noise[key] = Number(el.value);
        v.textContent = el.value;
        MERS.Core.recompute();
      });
    });

    $('#noiseSeedBtn').addEventListener('click', () => {
      const state = MERS.StateManager.getState();
      state.noise.seed = (Math.random() * 1e9) | 0;
      const seedInput = document.getElementById('noiseSeedInput');
      if (seedInput) seedInput.value = state.noise.seed;
      const remember = document.getElementById('rememberSeed');
      if (remember && remember.checked) {
        localStorage.setItem('mersNoiseSeed', String(state.noise.seed));
        localStorage.setItem('mersRememberSeed', '1');
      }
      MERS.NoiseGenerator.updateSeed(state.noise.seed);
      MERS.Core.recompute();
    });

    $('#noiseChannel').addEventListener('change', e => {
      const state = MERS.StateManager.getState();
      state.noise.channel = e.target.value;
      MERS.Core.recompute();
    });

    $('#noiseEnabled').addEventListener('change', e => {
      const state = MERS.StateManager.getState();
      state.noise.enabled = e.target.checked;
      MERS.Core.recompute();
    });

    $('#noiseMaskAlpha').addEventListener('change', e => {
      const state = MERS.StateManager.getState();
      state.noise.maskAlpha = e.target.checked;
      MERS.Core.recompute();
    });

    $('#noiseType').addEventListener('change', e => {
      const state = MERS.StateManager.getState();
      state.noise.type = e.target.value;
      MERS.Core.recompute();
    });

    // Animation controls
    MERS.AnimationManager.bindAnimSlider('#frameW', 'w');
    MERS.AnimationManager.bindAnimSlider('#frameH', 'h');
    MERS.AnimationManager.bindAnimSlider('#frameMs', 'ms', 'ms');

    $('#animOn').addEventListener('change', e => {
      const state = MERS.StateManager.getState();
      state.anim.on = e.target.checked;
      MERS.AnimationManager.setupAnim();
    });

    $('#frameIndex').addEventListener('input', e => {
      const state = MERS.StateManager.getState();
      state.anim.i = Number(e.target.value) || 0;
      MERS.PreviewManager.drawPreview();
    });

    // Paint tool controls
    const colorInput = document.getElementById('brushColor');
    const sizeInput = document.getElementById('brushSize');
    const toggleBtn = document.getElementById('toggleBrush');
    const bucketBtn = document.getElementById('toggleBucket');
    const selectBtn = document.getElementById('toggleSelect');
    const fillBtn = document.getElementById('fillSelection');
    const clearBtn = document.getElementById('clearSelection');
    const paintCanvas = document.getElementById('canvasPaint');
    const undoBtn = document.getElementById('undoPaint');
    const redoBtn = document.getElementById('redoPaint');
    const copyAlphaChk = document.getElementById('brushCopyAlpha');

    
const eyedropperBtn = document.getElementById('toggleEyedropper');
if (eyedropperBtn) {
  eyedropperBtn.addEventListener('click', () => {
    const paintState = MERS.StateManager.getPaintState();
    paintState.eyedropper = !paintState.eyedropper;
    eyedropperBtn.textContent = paintState.eyedropper ? '🧪 Eyedropper: On' : '🧪 Eyedropper: Off';
  });
}

    if (colorInput) {
      colorInput.addEventListener('input', e => {
        const hex = e.target.value;
        const r = parseInt(hex.slice(1, 3), 16);
        const g = parseInt(hex.slice(3, 5), 16);
        const b = parseInt(hex.slice(5, 7), 16);
        const paintState = MERS.StateManager.getPaintState();
        paintState.color = { r, g, b, a: 255 };
      });
    }

    if (sizeInput) {
      sizeInput.addEventListener('input', e => {
        const n = parseInt(e.target.value, 10);
        const paintState = MERS.StateManager.getPaintState();
        if (n > 0) paintState.size = n;
      });
    }

    if (toggleBtn) {
      toggleBtn.addEventListener('click', () => {
        const paintState = MERS.StateManager.getPaintState();
        paintState.enabled = !paintState.enabled;
        toggleBtn.textContent = paintState.enabled ? '🖌️ Brush: On' : '🖌️ Brush: Off';
        if (paintCanvas) paintCanvas.style.pointerEvents = (paintState.enabled || paintState.bucket || paintState.select) ? 'auto' : 'none';
        if (canvasOut) canvasOut.style.cursor = (paintState.enabled || paintState.bucket || paintState.select) ? 'crosshair' : 'default';
      });
    }

    if (bucketBtn) {
      bucketBtn.addEventListener('click', () => {
        const paintState = MERS.StateManager.getPaintState();
        paintState.bucket = !paintState.bucket;
        bucketBtn.textContent = paintState.bucket ? '🪣 Bucket: On' : '🪣 Bucket: Off';
        if (paintCanvas) paintCanvas.style.pointerEvents = (paintState.enabled || paintState.bucket || paintState.select) ? 'auto' : 'none';
        if (canvasOut) canvasOut.style.cursor = (paintState.enabled || paintState.bucket || paintState.select) ? 'crosshair' : 'default';
      });
    }

    if (selectBtn) {
      selectBtn.addEventListener('click', () => {
        const paintState = MERS.StateManager.getPaintState();
        const state = MERS.StateManager.getState();
        
        // Only allow select tool when a single channel is selected
        if (state.mode === 'rgba') {
          alert('Color select only works when a single channel (R, G, B, or A) is selected.');
          return;
        }
        
        paintState.select = !paintState.select;
        selectBtn.textContent = paintState.select ? '🎯 Select: On' : '🎯 Select: Off';
        if (paintCanvas) paintCanvas.style.pointerEvents = (paintState.enabled || paintState.bucket || paintState.select) ? 'auto' : 'none';
        if (canvasOut) canvasOut.style.cursor = (paintState.enabled || paintState.bucket || paintState.select) ? 'crosshair' : 'default';
      });
    }

    if (fillBtn) {
      fillBtn.addEventListener('click', () => {
        MERS.PaintTool.fillSelection();
      });
    }

    if (clearBtn) {
      clearBtn.addEventListener('click', () => {
        MERS.PaintTool.clearSelection();
      });
    }

    if (copyAlphaChk) {
      copyAlphaChk.addEventListener('change', e => {
        const paintState = MERS.StateManager.getPaintState();
        paintState.copyAlpha = e.target.checked;
      });
    }

    if (undoBtn) {
  undoBtn.addEventListener('click', () => {
    const state = MERS.StateManager.getState();
    const ps = MERS.StateManager.getPaintState();
    if (ps.undoStack.length === 0 || !state.out) return;

    // Save current to redo
    const current = {
      outData: state.out.data.slice(),
      brush:    (ps.layerBrush  ? ps.layerBrush.data.slice()  : (ps.layer ? ps.layer.data.slice() : null)),
      bucket:   (ps.layerBucket ? ps.layerBucket.data.slice() : null),
      maskBrush:(ps.maskBrush   ? ps.maskBrush.slice()        : (ps.mask ? ps.mask.slice() : null)),
      maskBucket:(ps.maskBucket ? ps.maskBucket.slice()       : null)
    };
    ps.redoStack.push(current);

    // Restore from undo
    const snap = ps.undoStack.pop();
    if (snap.brush) {
      if (ps.layerBrush) ps.layerBrush.data.set(snap.brush);
      else if (ps.layer) ps.layer.data.set(snap.brush);
    }
    if (snap.bucket && ps.layerBucket) ps.layerBucket.data.set(snap.bucket);
    if (snap.maskBrush) {
      if (ps.maskBrush) ps.maskBrush.set(snap.maskBrush);
      else if (ps.mask) ps.mask.set(snap.maskBrush);
    }
    if (snap.maskBucket && ps.maskBucket) ps.maskBucket.set(snap.maskBucket);
    if (snap.outData) state.out.data.set(snap.outData);

    // Recompose + refresh UI
    if (MERS.PaintTool.applyPaintOnOut) MERS.PaintTool.applyPaintOnOut();
    MERS.PaintTool.updateUndoRedoButtons();
    MERS.PreviewManager.drawPreview();
    MERS.HistogramManager.drawHistogram();
  });
}

    if (redoBtn) {
  redoBtn.addEventListener('click', () => {
    const state = MERS.StateManager.getState();
    const ps = MERS.StateManager.getPaintState();
    if (ps.redoStack.length === 0 || !state.out) return;

    // Save current to undo
    const current = {
      outData: state.out.data.slice(),
      brush:    (ps.layerBrush  ? ps.layerBrush.data.slice()  : (ps.layer ? ps.layer.data.slice() : null)),
      bucket:   (ps.layerBucket ? ps.layerBucket.data.slice() : null),
      maskBrush:(ps.maskBrush   ? ps.maskBrush.slice()        : (ps.mask ? ps.mask.slice() : null)),
      maskBucket:(ps.maskBucket ? ps.maskBucket.slice()       : null)
    };
    ps.undoStack.push(current);

    // Restore from redo
    const snap = ps.redoStack.pop();
    if (snap.brush) {
      if (ps.layerBrush) ps.layerBrush.data.set(snap.brush);
      else if (ps.layer) ps.layer.data.set(snap.brush);
    }
    if (snap.bucket && ps.layerBucket) ps.layerBucket.data.set(snap.bucket);
    if (snap.maskBrush) {
      if (ps.maskBrush) ps.maskBrush.set(snap.maskBrush);
      else if (ps.mask) ps.mask.set(snap.maskBrush);
    }
    if (snap.maskBucket && ps.maskBucket) ps.maskBucket.set(snap.maskBucket);
    if (snap.outData) state.out.data.set(snap.outData);

    // Recompose + refresh UI
    if (MERS.PaintTool.applyPaintOnOut) MERS.PaintTool.applyPaintOnOut();
    MERS.PaintTool.updateUndoRedoButtons();
    MERS.PreviewManager.drawPreview();
    MERS.HistogramManager.drawHistogram();
  });
}

    // Paint canvas events
    if (paintCanvas) {
      paintCanvas.addEventListener('mousedown', e => {
        const paintState = MERS.StateManager.getPaintState();
        
        
        if (e.button !== 0) { e.preventDefault(); return; }
if (paintState.select) {
          MERS.PaintTool.selectByColor(e);
          e.stopPropagation();
          e.preventDefault();
          return;
        }
        
        if (paintState.bucket) {
          MERS.PaintTool.saveHistory();
          MERS.PaintTool.bucketFillAt(e);
          e.stopPropagation();
          e.preventDefault();
          return;
        }
        
        if (!paintState.enabled) return;
        MERS.PaintTool.saveHistory();
        paintState.painting = true;
        MERS.PaintTool.paintAt(e);
        e.stopPropagation();
        e.preventDefault();
      });

      window.addEventListener('mousemove', e => {
        const paintState = MERS.StateManager.getPaintState();
        if (!paintState.enabled || !paintState.painting) return;
        const rect = paintCanvas.getBoundingClientRect();
        if (e.clientX >= rect.left && e.clientX <= rect.right && e.clientY >= rect.top && e.clientY <= rect.bottom) {
          MERS.PaintTool.paintAt(e);
        }
      });

      window.addEventListener('mouseup', () => {
        const paintState = MERS.StateManager.getPaintState();
        paintState.painting = false;
      });
    }    
// Eyedropper picking (on-demand)
['ref','src','out'].forEach(type => {
  const id = type === 'ref' ? 'canvasRef' : (type === 'src' ? 'canvasSrc' : 'canvasOut');
  const el = document.getElementById(id);
  if (!el) return;
  el.addEventListener('click', e => {
    const ps = MERS.StateManager.getPaintState();
    if (!ps.eyedropper) return;
    MERS.PaintTool.pickColorFromEvent(e, type);
    // auto-disable after a successful pick
    ps.eyedropper = false;
    const btn = document.getElementById('toggleEyedropper');
    if (btn) btn.textContent = '🧪 Eyedropper: Off';
  });
});

    // Histogram controls
    $('#toggleHist').addEventListener('click', () => {
      const histWin = document.getElementById('histWin');
      histWin.style.display = histWin.style.display === 'flex' ? 'none' : 'flex';
      MERS.HistogramManager.drawHistogram();
    });

    $('#histHide').addEventListener('click', () => {
      document.getElementById('histWin').style.display = 'none';
    });

    // Export controls
    $('#saveTGA').addEventListener('click', MERS.ExportManager.exportTGA);
    $('#saveZIP').addEventListener('click', MERS.ExportManager.exportZIP);

    // Seed persistence
    const seedInput = document.getElementById('noiseSeedInput');
    const remember = document.getElementById('rememberSeed');
    
    if (remember) {
      remember.checked = localStorage.getItem('mersRememberSeed') === '1';
      remember.addEventListener('change', () => {
        localStorage.setItem('mersRememberSeed', remember.checked ? '1' : '0');
        if (remember.checked) {
          const state = MERS.StateManager.getState();
          localStorage.setItem('mersNoiseSeed', String(state.noise.seed));
        }
      });
    }

    const savedSeed = localStorage.getItem('mersNoiseSeed');
    if (savedSeed && remember && remember.checked) {
      const v = parseInt(savedSeed, 10);
      if (!isNaN(v)) {
        const state = MERS.StateManager.getState();
        state.noise.seed = v;
        if (seedInput) seedInput.value = v;
        MERS.NoiseGenerator.updateSeed(state.noise.seed);
      }
    } else {
      const state = MERS.StateManager.getState();
      if (seedInput) seedInput.value = state.noise.seed;
    }

    if (seedInput) {
      seedInput.addEventListener('change', () => {
        const v = parseInt(seedInput.value, 10);
        if (!isNaN(v)) {
          const state = MERS.StateManager.getState();
          state.noise.seed = v;
          if (remember && remember.checked) {
            localStorage.setItem('mersNoiseSeed', String(v));
          }
          MERS.NoiseGenerator.updateSeed(state.noise.seed);
          MERS.Core.recompute();
        }
      });
    }
  }

  return {
    sliderTemplate,
    buildChannelGroup,
    setMappingOn,
    setGrayscale,
    updateRefControls,
    resetView,
    bindEventListeners
  };
})();

/***********************
 * Core Processing Module *
 ***********************/
MERS.Core = (function() {
  'use strict';
  
  const { clamp, toGray, lerp } = MERS.Utils;

  function recompute() {
    const state = MERS.StateManager.getState();
    if (!state.src) {
      MERS.PreviewManager.drawPreview();
      return;
    }
    
    const w = state.src.width, h = state.src.height;
    const result = new ImageData(w, h);
    const S = state.src.data, R = result.data;

    const cmap = (state.mappingOn && state.refMapByColor && state.refMapByColor.map) ? state.refMapByColor.map : null;
    const byPixel = state.mappingOn && state.refMatch === 'pixel' && state.refRes ? true : false;

    const noiseOn = state.noise.enabled && state.noise.channel !== 'none' && state.noise.amp > 0;
    
    for (let y = 0; y < h; y++) {
      for (let x = 0; x < w; x++) {
        const i = (y * w + x) * 4;
        const sr = S[i], sg = S[i + 1], sb = S[i + 2], sa = S[i + 3];
        const texGray = toGray(sr, sg, sb) / 255;

        let texR, texG, texB, texA;
        if (byPixel) {
          const ref = state.refRes && state.refRes.data;
          const Ridx = i;
          if (ref) {
            texR = ref[Ridx] / 255;
            texG = ref[Ridx + 1] / 255;
            texB = ref[Ridx + 2] / 255;
            texA = ref[Ridx + 3] / 255;
          } else {
            texR = texG = texB = texGray;
            texA = sa / 255;
          }
        } else if (cmap) {
          const key = sr + ',' + sg + ',' + sb + ',' + sa;
          const mapped = cmap.get(key);
          if (mapped) {
            texR = mapped[0] / 255;
            texG = mapped[1] / 255;
            texB = mapped[2] / 255;
            texA = mapped[3] / 255;
          } else {
            texR = texG = texB = texGray;
            texA = sa / 255;
          }
        } else {
          texR = texG = texB = texGray;
          texA = sa / 255;
        }

        function chVal(key, tex01) {
          const sl = state.sliders[key];
          let v01;
          if (state.mappingOn) {
            v01 = tex01;
          } else {
            const base01 = sl.base / 255;
            const infl01 = sl.infl / 100;
            v01 = base01 + (tex01 - base01) * infl01;
          }
          v01 = (v01 - 0.5) * (sl.contrast / 100) + 0.5;
          v01 += sl.bright / 255;
          v01 = Math.max(0, Math.min(1, v01));
          v01 = MERS.CurvesEditor.evalCurveAt(key, v01);
          if (sl.invert) v01 = 1 - v01;
          return Math.round(v01 * 255);
        }

        let RR = chVal('r', texR);
        let GG = chVal('g', texG);
        let BB = chVal('b', texB);
        let AA = chVal('a', texA);

        if (state.invertAll) {
          RR = 255 - RR;
          GG = 255 - GG;
          BB = 255 - BB;
          AA = 255 - AA;
        }

        if (noiseOn) {
          let allow = true;
          if (state.noise.maskAlpha) {
            allow = sa > 0;
          }
          if (allow) {
            const n = MERS.NoiseGenerator.getNoise(x / state.noise.scale, y / state.noise.scale) * state.noise.amp;
            const skew = n - state.noise.amp / 2;
            if (state.noise.channel === 'r') RR = clamp(RR + skew);
            if (state.noise.channel === 'g') GG = clamp(GG + skew);
            if (state.noise.channel === 'b') BB = clamp(BB + skew);
            if (state.noise.channel === 'a') AA = clamp(AA + skew);
          }
        }

        R[i] = RR;
        R[i + 1] = GG;
        R[i + 2] = BB;
        R[i + 3] = AA;
      }
    }
    
    state.out = result;
    MERS.PaintTool.applyPaintOnOut();
    MERS.PreviewManager.drawPreview();
    MERS.HistogramManager.drawHistogram();
  }

  function rebuildRefColorMap() {
    const state = MERS.StateManager.getState();
    state.refMapByColor = null;
    if (!state.src || !state.ref) return;
    
    const w = state.src.width, h = state.src.height;
    const refRes = MERS.ImageProcessor.resampleImageData(state.ref, w, h);
    state.refRes = refRes;
    const S = state.src.data, R = refRes.data;
    const map = new Map();
    
    for (let i = 0; i < w * h * 4; i += 4) {
      const key = S[i] + ',' + S[i + 1] + ',' + S[i + 2] + ',' + S[i + 3];
      if (!map.has(key)) {
        map.set(key, [R[i], R[i + 1], R[i + 2], R[i + 3]]);
      }
    }
    state.refMapByColor = { map: map, w: w, h: h };
  }

  return {
    recompute,
    rebuildRefColorMap
  };
})();

/***********************
 * Application Initialization *
 ***********************/
MERS.App = (function() {
  'use strict';
  
  function initialize() {
    // Set up histogram dragging
    MERS.HistogramManager.makeHistogramDraggable();
    
    // Initialize curves
    MERS.CurvesEditor.drawAllCurves();
    
    // Update UI state
    MERS.UIManager.updateRefControls();
    MERS.UIManager.setGrayscale(false);
    
    // Bind all event listeners
    MERS.UIManager.bindEventListeners();
    
    // Initialize paint tool buttons
    MERS.PaintTool.updateUndoRedoButtons();
    MERS.PaintTool.updateSelectionButtons();

    // Expose global helpers for compatibility
    window.__initPaintLayer = MERS.PaintTool.initPaintLayer;
    window.__applyPaintOnOut = MERS.PaintTool.applyPaintOnOut;
    
    // Start selection animation loop
    function animateSelection() {
      MERS.PaintTool.drawSelectionOverlay();
      requestAnimationFrame(animateSelection);
    }
    animateSelection();
  }

  return {
    initialize
  };
})();

// Initialize the application when DOM is loaded
window.addEventListener('load', () => {
  MERS.App.initialize();
});

</script>
<!-- JSZip for ZIP export -->
<script src="https://cdn.jsdelivr.net/npm/jszip@3.10.1/dist/jszip.min.js"></script>
<!-- Attribution footer -->
<div style="text-align:center; color: var(--muted); font-size: 11px; padding: 12px 0;">
    Made with GPT 5 and Claude AI
  </div>
<script>
// --- Layers: state + UI + patching modules (non-destructive) ---
(function(){
  // Helper: safe get of modules
  function ready(fn){
    if (document.readyState !== 'loading') fn(); else document.addEventListener('DOMContentLoaded', fn);
  }
  ready(function(){
    if (!window.MERS || !MERS.StateManager) return;

    const st = MERS.StateManager.getState();
    // Add default layers state if missing
    st.layers = st.layers || {
      brush:  { visible: true },
      bucket: { visible: true },
      sliders:{ visible: true },
      curves: { visible: true },
      noise:  { visible: true }
    };

    // Patch PaintTool to support separate Brush/Bucket layers (non-breaking)
    (function patchPaint(){
      const PT = MERS.PaintTool;
      if (!PT) return;

      // Keep references to original functions when needed
      const origInit = PT.initPaintLayer;
      const origApply = PT.applyPaintOnOut;
      const origPaintAt = PT.paintAt;
      const origBucket = PT.bucketFillAt;

      // Extend paint state with dual layers
      PT.initPaintLayer = function(w, h){
        const ps = MERS.StateManager.getPaintState();
        function makeImageData(w,h){
          try { return new ImageData(new Uint8ClampedArray(w*h*4), w, h); }
          catch(e){ const arr=new Uint8ClampedArray(w*h*4); return {data:arr,width:w,height:h}; }
        }
        function makeMask(w,h){
          try { return new Uint8Array(w*h); }
          catch(e){ return new Array(w*h).fill(0); }
        }
        ps.layerBrush  = makeImageData(w,h);
        ps.layerBucket = makeImageData(w,h);
        ps.maskBrush   = makeMask(w,h);
        ps.maskBucket  = makeMask(w,h);
        // Maintain legacy fields pointing to Brush so existing UI continues to work
        ps.layer = ps.layerBrush;
        ps.mask  = ps.maskBrush;
        ps.selection = makeMask(w,h);
        ps.undoStack = ps.undoStack || [];
        ps.redoStack = ps.redoStack || [];
      };

      // Composite: bucket under brush; honor visibility toggles
      PT.applyPaintOnOut = function(){
        const state = MERS.StateManager.getState();
        const ps = MERS.StateManager.getPaintState();
        if (!state.out) return;
        const outD = state.out.data;

        function apply(lay, mask){
          if (!lay || !mask) return;
          const w = state.out.width, h = state.out.height;
          const L = lay.data;
          for (let p = 0; p < w*h; p++){
            const m = mask[p];
            if (!m) continue;
            const i = p*4;
            if (m & 1) outD[i+0] = L[i+0];
            if (m & 2) outD[i+1] = L[i+1];
            if (m & 4) outD[i+2] = L[i+2];
            if (m & 8) outD[i+3] = L[i+3];
          }
        }

        // order: bucket then brush
        if (state.layers.bucket.visible) apply(ps.layerBucket, ps.maskBucket);
        if (state.layers.brush.visible)  apply(ps.layerBrush,  ps.maskBrush);
      };

      // Re-implement paintAt to target Brush layer only (brush tool)
      PT.paintAt = function(e){
        const state = MERS.StateManager.getState();
        const ps = MERS.StateManager.getPaintState();
        if (!state.out || !ps.layerBrush) return;
        const mode = state.mode;
        if (!(mode === 'r' || mode === 'g' || mode === 'b' || mode === 'a')) return;

        // Helpers from existing module
        const chInfo = MERS.PaintTool.chInfo;
        const activeChannel = MERS.PaintTool.activeChannel;
        const mapEventToOutImage = MERS.PaintTool.mapEventToOutImage;

        const ch = activeChannel(); if (!ch) return;
        const {off, bit} = chInfo(ch);
        const coord = mapEventToOutImage(e); if (!coord) return;

        const w = ps.layerBrush.width, h = ps.layerBrush.height;
        const size = ps.size || 1;
        const px = coord.x, py = coord.y;
        const col = [ps.color.r, ps.color.g, ps.color.b, ps.color.a][off];

        for (let dy=0; dy<size; dy++){
          const y = py + dy; if (y<0 || y>=h) continue;
          for (let dx=0; dx<size; dx++){
            const x = px + dx; if (x<0 || x>=w) continue;
            const i = (y*w + x)*4, p = (y*w + x);
            ps.layerBrush.data[i+off] = col;
            ps.maskBrush[p] = (ps.maskBrush[p] | bit);
          }
        }
        // Re-apply overlays & refresh
        PT.applyPaintOnOut();
        MERS.PreviewManager.drawPreview();
      };

      // Flood fill now targets Bucket layer
      PT.bucketFillAt = function(e){
        const state = MERS.StateManager.getState();
        const ps = MERS.StateManager.getPaintState();
        if (!state.out || !ps.layerBucket) return;

        const chInfo = MERS.PaintTool.chInfo;
        const activeChannel = MERS.PaintTool.activeChannel;
        const mapEventToOutImage = MERS.PaintTool.mapEventToOutImage;

        const ch = activeChannel(); if (!ch) return;
        const {off, bit} = chInfo(ch);
        const coord = mapEventToOutImage(e); if (!coord) return;

        const w = state.out.width, h = state.out.height;
        const data = state.out.data; // use current out to determine target region
        const L = ps.layerBucket.data;
        const idx0 = (coord.y * w + coord.x) * 4;
        const targetV = data[idx0 + off];
        const newV = [ps.color.r, ps.color.g, ps.color.b, ps.color.a][off];
        if (targetV === newV) return;

        const seen = new Uint8Array(w*h);
        const stack = [idx0];
        seen[(idx0/4)|0] = 1;
        const pushIf = (i)=>{
          const p = (i/4)|0;
          if (seen[p]) return;
          if (data[i+off] === targetV){ seen[p]=1; stack.push(i); }
        };

        while (stack.length){
          const i = stack.pop();
          const p = (i/4)|0;
          data[i+off] = newV;    // update preview immediately
          L[i+off] = newV;       // write to bucket layer
          ps.maskBucket[p] = (ps.maskBucket[p] | bit);
          const x = p % w, y = (p / w) | 0;
          if (x>0)     pushIf(i-4);
          if (x<w-1)   pushIf(i+4);
          if (y>0)     pushIf(i-4*w);
          if (y<h-1)   pushIf(i+4*w);
        }
        PT.applyPaintOnOut();
        MERS.PreviewManager.drawPreview();
        MERS.HistogramManager.drawHistogram();
      };

    })();

    // Patch Curves evaluation to allow visibility toggle
    (function patchCurves(){
      if (!MERS.CurvesEditor) return;
      const origEval = MERS.CurvesEditor.evalCurveAt;
      MERS.CurvesEditor.evalCurveAt = function(ch, x){
        const s = MERS.StateManager.getState();
        if (s.layers && s.layers.curves && s.layers.curves.visible === false) return x; // identity
        return origEval(ch, x);
      };
    })();

    // Wrap Core.recompute to optionally bypass Sliders & Noise
    (function patchCore(){
      if (!MERS.Core) return;
      const orig = MERS.Core.recompute;
      MERS.Core.recompute = function(){
        const s = MERS.StateManager.getState();
        // Save and possibly neutralize sliders + noise
        const saved = JSON.parse(JSON.stringify({ sliders: s.sliders, noise: s.noise }));
        if (s.layers && s.layers.sliders && s.layers.sliders.visible === false){
          // Set identity sliders
          s.sliders = {
            r:{ base:0, infl:100, bright:0, contrast:100, invert:false },
            g:{ base:0, infl:100, bright:0, contrast:100, invert:false },
            b:{ base:0, infl:100, bright:0, contrast:100, invert:false },
            a:{ base:0, infl:100, bright:0, contrast:100, invert:false }
          };
        }
        if (s.layers && s.layers.noise && s.layers.noise.visible === false){
          s.noise = Object.assign({}, s.noise, { enabled:false });
        }
        try {
          orig();
        } finally {
          // Restore
          if (saved.sliders) s.sliders = saved.sliders;
          if (saved.noise)   s.noise = saved.noise;
        }
      };
    })();

    // --- UI wiring for the eye toggles
    function setEye(btn, on){
      btn.classList.toggle('off', !on);
      btn.textContent = on ? '👁' : '🚫';
    }
    const mapping = [
      ['layer_vis_brush',  'brush'],
      ['layer_vis_bucket', 'bucket'],
      ['layer_vis_sliders','sliders'],
      ['layer_vis_curves', 'curves'],
      ['layer_vis_noise',  'noise']
    ];
    mapping.forEach(([id,key])=>{
      const el = document.getElementById(id);
      if (!el) return;
      // Init
      setEye(el, st.layers[key].visible !== false);
      el.addEventListener('click', function(){
        const cur = !!st.layers[key].visible;
        st.layers[key].visible = !cur;
        setEye(el, !cur);
        // Recompute vs redraw
        if (key==='brush' || key==='bucket'){
          // just redraw overlays
          if (MERS.StateManager.getState().out){
            MERS.Core.recompute(); // ensure consistent overlay after toggles
          }
        } else {
          MERS.Core.recompute();
        }
      });
    });

  }); // ready
})();
</script>
<!-- === Patch: Right‑canvas color select uses REF pixels and mirrors mask to OUT (REPLACE) === -->
<script>

(function(){
  if (!window.MERS || !MERS.StateManager || !MERS.PaintTool) return;

  function getState(){ return MERS.StateManager.getState(); }
  function getPaint(){ return MERS.StateManager.getPaintState(); }

  function mapEventToRefImage(e){
    const st = getState();
    if (!st || !st.ref) return null;
    const ref = document.getElementById('canvasRef');
    const rect = ref.getBoundingClientRect();
    const client = ('clientX' in e) ? {x: e.clientX, y: e.clientY} :
                   (e.touches && e.touches[0]) ? {x: e.touches[0].clientX, y: e.touches[0].clientY} :
                   null;
    if (!client) return null;
    const xCanvas = client.x - rect.left;
    const yCanvas = client.y - rect.top;

    const w = st.ref.width, h = st.ref.height;
    const frameW = st.anim.w || w;
    const frameH = st.anim.h || h;
    const frames = Math.max(1, Math.floor(h / frameH));
    const frameIndex = st.anim.on ? st.anim.i : Math.min(st.anim.i, frames - 1);
    const frameY = frameIndex * frameH;

    const viewW = Math.min(frameW, w);
    const viewH = Math.min(frameH, h - frameY);
    const fit = Math.min(rect.width / viewW, rect.height / viewH);
    const scale = fit * st.zoom;
    const dx = Math.round((rect.width - viewW * scale) / 2 + st.panX);
    const dy = Math.round((rect.height - viewH * scale) / 2 + st.panY);

    const ix = (xCanvas - dx) / scale;
    const iy = (yCanvas - dy) / scale;
    const xImg = Math.floor(ix + 1e-9);
    const yImg = Math.floor(iy + 1e-9) + frameY;
    if (isNaN(xImg) || isNaN(yImg)) return null;
    if (xImg < 0 || xImg >= w || yImg < 0 || yImg >= h) return null;
    return { x: xImg, y: yImg, frameY, frameH, frameW };
  }

  function isSingleChannel(st){
    return st && (st.mode === 'r' || st.mode === 'g' || st.mode === 'b' || st.mode === 'a');
  }

  // Select by color from REF image; apply mask to selection (mirrored to OUT overlay)
  function selectByColorFromREFReplace(e){
    const st = getState();
    const ps = getPaint();
    if (!(ps && ps.select && isSingleChannel(st))) return false;
    if (!st.ref || !st.out || !ps.selection) return false;

    const coord = mapEventToRefImage(e);
    if (!coord) return false;

    const refD = st.ref.data;
    const outW = st.out.width, outH = st.out.height;
    const refW = st.ref.width, refH = st.ref.height;
    const sameSize = (outW === refW) && (outH === refH);
    if (!sameSize) {
      // Basic guard: if sizes differ, bail to avoid misalignment
      console.warn("[Patch] REF/OUT dimensions differ; selection aborted.");
      return false;
    }

    // Determine channel offset
    const chInfo = MERS.PaintTool.chInfo;
    const { off } = chInfo(st.mode);

    // Target value at clicked REF pixel
    const idxRef = (coord.y * refW + coord.x) * 4;
    const target = refD[idxRef + off];

    const sel = ps.selection;

    // Clear previous selection unless Shift is held (additive multi-select)
    if (!(e && e.shiftKey)) {
      if (sel.fill) sel.fill(0);
      else for (let i = 0; i < sel.length; i++) sel[i] = 0;
    }

    // Limit to current frame bounds (mirror left-canvas behavior on spritesheets)
    const yStart = coord.frameY;
    const yEnd   = Math.min(coord.frameY + coord.frameH, refH);
    const xStart = 0;
    const xEnd   = Math.min(coord.frameW, refW);

    // Build selection mask from REF pixels only
    for (let y = yStart; y < yEnd; y++) {
      let rowIdx = y * refW;
      for (let x = xStart; x < xEnd; x++) {
        const p = rowIdx + x;
        const i = p * 4;
        if (refD[i + off] === target) sel[p] = 1;
      }
    }

    if (MERS.PaintTool.drawSelectionOverlay) MERS.PaintTool.drawSelectionOverlay();
    if (MERS.PaintTool.updateSelectionButtons) MERS.PaintTool.updateSelectionButtons();
    return true;
  }

  // Hook right-canvas events: trigger on pointerdown and block conflicting handlers on release
  (function attachHandlers(){
    const ref = document.getElementById('canvasRef');
    if (!ref) return;

    const opts = { capture: true, passive: false };
    const handler = function(e){
      const ok = selectByColorFromREFReplace(e);
      if (ok) {
        e.stopImmediatePropagation();
        if (typeof e.preventDefault === 'function') e.preventDefault();
        return false;
      }
    };
    const block = function(e){
      const st = getState(), ps = getPaint();
      if (ps && ps.select && isSingleChannel(st)) {
        e.stopImmediatePropagation();
        if (typeof e.preventDefault === 'function') e.preventDefault();
        return false;
      }
    };

    ref.addEventListener('pointerdown', handler, opts);
    ref.addEventListener('mousedown', handler, opts);
    ref.addEventListener('touchstart', handler, opts);

    ref.addEventListener('pointerup', block, opts);
    ref.addEventListener('mouseup', block, opts);
    ref.addEventListener('click', block, opts);
    ref.addEventListener('touchend', block, opts);
    ref.addEventListener('pointercancel', block, opts);

    // Cursor sync
    const btn = document.getElementById('toggleSelect');
    const sync = ()=>{
      try {
        const ps = getPaint();
        ref.style.cursor = (ps && ps.select) ? 'crosshair' : 'default';
      } catch(_){}
    };
    if (btn) btn.addEventListener('click', sync);
    setTimeout(sync, 0);
  })();
})();

</script>
<!-- UPSCALED_V1V2_PATCH_START -->
<script>
(function() {
  function ready(fn) { if (document.readyState !== 'loading') fn(); else document.addEventListener('DOMContentLoaded', fn); }
  ready(function() {
    if (!window.MERS || !MERS.StateManager || !MERS.Core || !MERS.ImageProcessor) return;

    
    // Coerce legacy selection
    try { if (MERS.StateManager.getState().refMatch === 'upscaled_v1') MERS.StateManager.getState().refMatch = 'upscaled_v2'; } catch(_) {}
// ---- Ensure only V2 exists; remove V1 if present ----
    document.querySelectorAll('select.refMatchSel').forEach(sel => {
      // remove any V1 option
      [...sel.options].forEach((o, i) => { if (o.value === 'upscaled_v1') sel.remove(i); });
      // ensure V2 exists
      const hasV2 = [...sel.options].some(o => o.value === 'upscaled_v2');
      if (!hasV2) sel.add(new Option('Upscaled V2 (tolerant)', 'upscaled_v2'));
    });

    // (Removed) Upscaled tolerance UI was removed at user request.
function showTolFor(mode){ /* no UI */ }
const st = MERS.StateManager.getState();
if (typeof st.upTol !== 'number') st.upTol = 0;

// ---- Downscale helper (2×2 modal) ----
    function downscaleMode2x(imgd) {
      const W = imgd.width, H = imgd.height;
      const w = Math.max(1, Math.floor(W/2)), h = Math.max(1, Math.floor(H/2));
      const out = new ImageData(w,h);
      const S = imgd.data, R = out.data;
      for (let y=0;y<h;y++) {
        for (let x=0;x<w;x++) {
          const counts = new Map();
          for (let dy=0; dy<2; dy++) {
            for (let dx=0; dx<2; dx++) {
              const sx = Math.min(W-1, x*2+dx), sy = Math.min(H-1, y*2+dy);
              const i = (sy*W+sx)*4;
              const key = S[i]+','+S[i+1]+','+S[i+2]+','+S[i+3];
              counts.set(key, (counts.get(key)||0)+1);
            }
          }
          let bestKey = null, bestCount = -1;
          for (const [k,c] of counts.entries()) { if (c>bestCount) { bestCount=c; bestKey=k; } }
          const [r,g,b,a] = bestKey.split(',').map(Number);
          const o = (y*w+x)*4; R[o]=r; R[o+1]=g; R[o+2]=b; R[o+3]=a;
        }
      }
      return out;
    }

    // ---- Strict 1:1 mapping like the Python script ----
    function buildStrictMap(src16, ref16) {
      const S = src16.data, R = ref16.data;
      if (src16.width !== ref16.width || src16.height !== ref16.height) return { error: 'Mismatched 16× dimensions' };
      const seen = new Map(); // src rgba key -> Set of target keys
      const toKey = (arr,i)=> arr[i]+','+arr[i+1]+','+arr[i+2]+','+arr[i+3];
      for (let i=0;i<S.length;i+=4) {
        const sk = toKey(S,i), rk = toKey(R,i);
        if (!seen.has(sk)) seen.set(sk, new Set([rk]));
        else seen.get(sk).add(rk);
      }
      const mapping = new Map();
      for (const [sk, set] of seen.entries()) {
        if (set.size > 1) return { error: 'Inconsistent color mapping between 16× PNG and 16× TGA' };
        mapping.set(sk, [...set][0]);
      }
      return { mapping };
    }

    function hasOnlyKnownColors(pixels32, palette16Keys, tol) {
      // pixels32: ImageData of 32× src
      const d = pixels32.data;
      for (let i=0;i<d.length;i+=4) {
        const sk = d[i]+','+d[i+1]+','+d[i+2]+','+d[i+3];
        // exact or tolerant presence in 16× palette
        if (palette16Keys.has(sk)) continue;
        if (tol > 0) {
          let ok = false;
          for (const k of palette16Keys) {
            const [R,G,B,A] = k.split(',').map(Number);
            if (Math.abs(R-d[i])<=tol && Math.abs(G-d[i+1])<=tol && Math.abs(B-d[i+2])<=tol && Math.abs(A-d[i+3])<=tol) { ok = True; break; }
          }
          if (ok) continue;
        }
        return false;
      }
      return true;
    }

    // Wrap rebuildRefColorMap to support both V1 and V2
    const _origRebuild = MERS.Core.rebuildRefColorMap;
    MERS.Core.rebuildRefColorMap = function() {
      const state = MERS.StateManager.getState();
      state.refMapByColor = null;
      if (!state.src || !state.ref) return;

      const w = state.src.width, h = state.src.height;
      state.refRes = MERS.ImageProcessor.resampleImageData(state.ref, w, h); // needed for pixel mode

      // New: "vanilla_tga" mode
      if (state.refMatch === 'vanilla_tga') {
        // Align both images to the reference TGA's native size, then create a color->color vote map.
        const baseW = Math.max(1, state.ref.width  || Math.floor(w / 2));
        const baseH = Math.max(1, state.ref.height || Math.floor(h / 2));
        const srcBase = MERS.ImageProcessor.resampleImageData(state.src, baseW, baseH);
        const refBase = MERS.ImageProcessor.resampleImageData(state.ref, baseW, baseH);
        
        const S = srcBase.data, R = refBase.data;
        const votes = new Map();  // srcKey -> Map(tgtKey->count)
        const toKey = (arr,i)=> arr[i]+','+arr[i+1]+','+arr[i+2]+','+arr[i+3];
        for (let i=0;i<baseW*baseH*4;i+=4) {
          const sk = toKey(S,i), rk = toKey(R,i);
          if (!votes.has(sk)) votes.set(sk, new Map());
          const inner = votes.get(sk);
          inner.set(rk, (inner.get(rk)||0)+1);
        }
        // Reduce vote map to a simple "most common target" map
        const baseMap = new Map();
        const srcKeys = [];
        for (const [sk, inner] of votes.entries()) {
          let best = null, bestN = -1;
          for (const [rk, n] of inner.entries()) { if (n>bestN) { bestN=n; best=rk; } }
          baseMap.set(sk, best.split(',').map(Number));
          srcKeys.push(sk);
        }
        // Build a tolerant lookup helper so unseen colours still resolve
        const vanillaMap = {
          _m: baseMap,
          _keys: srcKeys,
          findExact(key){ return this._m.get(key); },
          findApproxWithinTol(key, tol){
            if (!this._keys || tol <= 0) return undefined;
            const [r,g,b,a] = key.split(',').map(Number);
            let res = undefined;
            for (let i=0;i<this._keys.length;i++) {
              const k = this._keys[i];
              const [R,G,B,A] = k.split(',').map(Number);
              if (Math.abs(R-r) <= tol && Math.abs(G-g) <= tol && Math.abs(B-b) <= tol && Math.abs(A-a) <= tol) {
                res = this._m.get(k);
                this._m.set(key, res);
                break;
              }
            }
            return res;
          },
          get(key){
            // Prefer exact; fall back to small tolerance to be resilient to compression/filters
            let out = this.findExact(key);
            if (!out) out = this.findApproxWithinTol(key, (MERS.StateManager.getState().upTol||6));
            return out;
          }
        };
        state.refMapByColor = { map: vanillaMap, w: baseW, h: baseH, vanilla_tga: true };
        return;
      }

      if (state.refMatch === 'upscaled_v2') {        const baseW = Math.max(1, Math.floor(w/2)), baseH = Math.max(1, Math.floor(h/2));
        const src16 = downscaleMode2x(state.src); // proxy for 16× PNG
        const ref16 = MERS.ImageProcessor.resampleImageData(state.ref, baseW, baseH);

        

        if (state.refMatch === 'upscaled_v2') {
          // TOLERANT variant (previous implementation)
          const S = src16.data, R = ref16.data;
          const votes = new Map();  // srcKey -> Map(tgtKey->count)
          const toKey = (arr,i)=> arr[i]+','+arr[i+1]+','+arr[i+2]+','+arr[i+3];
          for (let i=0;i<baseW*baseH*4;i+=4) {
            const sk = toKey(S,i), rk = toKey(R,i);
            if (!votes.has(sk)) votes.set(sk, new Map());
            const inner = votes.get(sk);
            inner.set(rk, (inner.get(rk)||0)+1);
          }
          const baseMap = new Map();
          const srcKeys = [];
          for (const [sk, inner] of votes.entries()) {
            let best = null, bestN = -1;
            for (const [rk, n] of inner.entries()) { if (n>bestN) { bestN=n; best=rk; } }
            baseMap.set(sk, best.split(',').map(Number));
            srcKeys.push(sk);
          }
          const upscaledMap = {
            _m: baseMap,
            _keys: srcKeys,
            get: function(key) {
              const hit = this._m.get(key);
              if (hit) return hit;
              const tol = (MERS.StateManager.getState().upTol|0) || 0;
              if (tol <= 0) return undefined;
              const [r,g,b,a] = key.split(',').map(Number);
              let res = undefined;
              for (let i=0;i<this._keys.length;i++) {
                const k = this._keys[i];
                const [R,G,B,A] = k.split(',').map(Number);
                if (Math.abs(R-r) <= tol && Math.abs(G-g) <= tol && Math.abs(B-b) <= tol && Math.abs(A-a) <= tol) {
                  res = this._m.get(k);
                  this._m.set(key, res);
                  break;
                }
              }
              return res;
            }
          };
          state.refMapByColor = { map: upscaledMap, w: baseW, h: baseH, upscaled_v2: true };
          return;
        }
      }

      // Other modes: original
      return _origRebuild.call(MERS.Core);
    };

    function onSelectChange(el) {
      const s = MERS.StateManager.getState();
      s.refMatch = el.value;
      document.querySelectorAll('.refMatchSel').forEach(sel => sel.value = s.refMatch);
      showTolFor(s.refMatch);
      MERS.Core.rebuildRefColorMap();
      MERS.Core.recompute();
    }
    function wireSelect(id) {
      const el = document.getElementById(id);
      if (!el) return;
      el.addEventListener('change', () => onSelectChange(el), { capture: true });
    }
    wireSelect('refMatchLeft');
    wireSelect('refMatchTop');

    // Initial state/visibility
    const currentSel = document.getElementById('refMatchLeft') || document.getElementById('refMatchTop');
    const mode = currentSel ? currentSel.value : (MERS.StateManager.getState().refMatch || 'color');
    showTolFor(mode);
    MERS.Core.rebuildRefColorMap();
    MERS.Core.recompute();
  });
})();
</script>
<!-- UPSCALED_V1V2_PATCH_END -->
<script>
function parseTGA(view) {
  // --- Header ---
  const idLen = view.getUint8(0);
  const cmType = view.getUint8(1);        // 0 = none, 1 = has color map
  const imageType = view.getUint8(2);     // 1/9 = color-mapped, 2/10 = truecolor, 3/11 = grayscale
  const cmFirst = view.getUint16(3, true);
  const cmLen   = view.getUint16(5, true);
  const cmBpp   = view.getUint8(7);       // bits per palette entry
  const width   = view.getUint16(12, true);
  const height  = view.getUint16(14, true);
  const bpp     = view.getUint8(16);      // bits per pixel of image data
  const desc    = view.getUint8(17);
  const originTop = (desc & 0x20) !== 0;

  let p = 18 + idLen; // skip ID field

  // --- Palette (if present) ---
  let palette = null;
  if (cmType === 1 && cmLen > 0) {
    palette = new Array(cmFirst + cmLen);
    for (let i = 0; i < cmLen; i++) {
      if (cmBpp === 24 || cmBpp === 32) {
        const B = view.getUint8(p++), G = view.getUint8(p++), R = view.getUint8(p++);
        const A = (cmBpp === 32) ? view.getUint8(p++) : 255;
        palette[cmFirst + i] = [R, G, B, A];
      } else if (cmBpp === 15 || cmBpp === 16) {
        const v = view.getUint16(p, true); p += 2;
        // 5-5-5 (BGR). Treat attribute bit as opaque.
        const B = ((v       & 0x1F) * 255 + 15) / 31 | 0;
        const G = (((v>>5)  & 0x1F) * 255 + 15) / 31 | 0;
        const R = (((v>>10) & 0x1F) * 255 + 15) / 31 | 0;
        palette[cmFirst + i] = [R, G, B, 255];
      } else {
        throw new Error('Unsupported TGA palette entry size');
      }
    }
  }

  // Helpers
  const out = new Uint8ClampedArray(width * height * 4);
  function writePixel(y, x, r, g, b, a) {
    const row = originTop ? y : (height - 1 - y);
    const i = (row * width + x) * 4;
    out[i] = r; out[i+1] = g; out[i+2] = b; out[i+3] = a;
  }

  function readTruecolorPixel() {
    if (bpp === 24) {
      const B = view.getUint8(p++), G = view.getUint8(p++), R = view.getUint8(p++);
      return [R, G, B, 255];
    } else if (bpp === 32) {
      const B = view.getUint8(p++), G = view.getUint8(p++), R = view.getUint8(p++), A = view.getUint8(p++);
      return [R, G, B, A];
    }
    throw new Error('Unsupported truecolor bpp');
  }

  function readIndexedPixel() {
    if (bpp !== 8 || !palette) throw new Error('Unsupported indexed TGA');
    const idx = view.getUint8(p++);
    const px = palette[idx] || palette[cmFirst] || [0,0,0,255];
    return px;
  }

  function readGrayPixel() {
    if (bpp !== 8) throw new Error('Unsupported grayscale bpp');
    const v = view.getUint8(p++);
    return [v, v, v, 255];
  }

  function fillUncompressed(readOne) {
    for (let y = 0; y < height; y++) {
      for (let x = 0; x < width; x++) {
        const [r,g,b,a] = readOne();
        writePixel(y, x, r,g,b,a);
      }
    }
  }

  function fillRLE(readOne) {
    let x = 0, y = 0;
    const total = width * height;
    let written = 0;
    while (written < total) {
      const header = view.getUint8(p++);
      const count = (header & 0x7F) + 1;
      if (header & 0x80) {
        // run-length packet
        const px = readOne();
        for (let i = 0; i < count; i++) {
          writePixel(y, x, px[0], px[1], px[2], px[3]);
          if (++x >= width) { x = 0; y++; }
          written++;
        }
      } else {
        // raw packet
        for (let i = 0; i < count; i++) {
          const px = readOne();
          writePixel(y, x, px[0], px[1], px[2], px[3]);
          if (++x >= width) { x = 0; y++; }
          written++;
        }
      }
    }
  }

  // --- Decode by image type ---
  switch (imageType) {
    case 2:  fillUncompressed(readTruecolorPixel); break;       // truecolor
    case 10: fillRLE(readTruecolorPixel); break;                // truecolor RLE
    case 1:  fillUncompressed(readIndexedPixel); break;         // indexed
    case 9:  fillRLE(readIndexedPixel); break;                  // indexed RLE
    case 3:  fillUncompressed(readGrayPixel); break;            // grayscale
    case 11: fillRLE(readGrayPixel); break;                     // grayscale RLE
    default: throw new Error('Unsupported TGA image type');
  }

  return new ImageData(out, width, height);
}

// If the app uses a namespace, also hook it:
try {
  if (typeof MERS !== "undefined" && MERS.ImageProcessor) {
    MERS.ImageProcessor.parseTGA = parseTGA;
  }
} catch (e) {}
</script>
<script>
function parseTGA(view) {
  // --- Header ---
  const idLen = view.getUint8(0);
  const cmType = view.getUint8(1);        // 0 = none, 1 = has color map
  const imageType = view.getUint8(2);     // 1/9 = color-mapped, 2/10 = truecolor, 3/11 = grayscale
  const cmFirst = view.getUint16(3, true);
  const cmLen   = view.getUint16(5, true);
  const cmBpp   = view.getUint8(7);       // bits per palette entry
  const width   = view.getUint16(12, true);
  const height  = view.getUint16(14, true);
  const bpp     = view.getUint8(16);      // bits per pixel of image data
  const desc    = view.getUint8(17);
  const originTop  = (desc & 0x20) !== 0; // Bit 5: 0 = bottom, 1 = top
  const originLeft = (desc & 0x10) === 0; // Bit 4: 0 = left-to-right, 1 = right-to-left (so true when bit=0)
  const alphaBits  = (desc & 0x0F);       // number of attribute/alpha bits per pixel (0..8 or 0..1 for 16bpp)
  const interleave = (desc & 0x03);       // 0 none, 1 two-way, 2 four-way

  let p = 18 + idLen; // skip ID field

  // --- Palette (if present) ---
  let palette = null;
  if (cmType === 1 && cmLen > 0) {
    palette = new Array(cmFirst + cmLen);
    for (let i = 0; i < cmLen; i++) {
      if (cmBpp === 24 || cmBpp === 32) {
        const B = view.getUint8(p++), G = view.getUint8(p++), R = view.getUint8(p++);
        const A = (cmBpp === 32) ? view.getUint8(p++) : 255;
        palette[cmFirst + i] = [R, G, B, A];
      } else if (cmBpp === 15 || cmBpp === 16) {
        const v = view.getUint16(p, true); p += 2;
        // 5-5-5 (BGR). Attribute bit ignored (opaque).
        const B = ((v       & 0x1F) * 255 + 15) / 31 | 0;
        const G = (((v>>5)  & 0x1F) * 255 + 15) / 31 | 0;
        const R = (((v>>10) & 0x1F) * 255 + 15) / 31 | 0;
        palette[cmFirst + i] = [R, G, B, 255];
      } else {
        throw new Error('Unsupported TGA palette entry size');
      }
    }
  }

  // Helpers
  const out = new Uint8ClampedArray(width * height * 4);

  function mapRow(ySeq) {
    // Handle interleaving (2-way and 4-way)
    let row = ySeq;
    if (interleave === 1) { // two-way
      const half = Math.ceil(height / 2);
      row = (ySeq < half) ? ySeq * 2 : (ySeq - half) * 2 + 1;
    } else if (interleave === 2) { // four-way
      const q = Math.ceil(height / 4);
      if (ySeq < q) row = ySeq * 4;
      else if (ySeq < 2*q) row = (ySeq - q) * 4 + 1;
      else if (ySeq < 3*q) row = (ySeq - 2*q) * 4 + 2;
      else row = (ySeq - 3*q) * 4 + 3;
    }
    // Vertical origin
    row = originTop ? row : (height - 1 - row);
    return row;
  }

  function writePixel(ySeq, xSeq, r, g, b, a) {
    const row = mapRow(ySeq);
    const col = originLeft ? xSeq : (width - 1 - xSeq);
    if (row < 0 || row >= height || col < 0 || col >= width) return;
    const i = (row * width + col) * 4;
    out[i] = r; out[i+1] = g; out[i+2] = b; out[i+3] = a;
  }

  function expand5(v) { return ((v * 255 + 15) / 31) | 0; }

  function readTruecolorPixel() {
    if (bpp === 24) {
      const B = view.getUint8(p++), G = view.getUint8(p++), R = view.getUint8(p++);
      return [R, G, B, 255];
    } else if (bpp === 32) {
      const B = view.getUint8(p++), G = view.getUint8(p++), R = view.getUint8(p++), A = view.getUint8(p++);
      return [R, G, B, A];
    } else if (bpp === 16 || bpp === 15) {
      const v = view.getUint16(p, true); p += 2;
      const B = expand5( v        & 0x1F);
      const G = expand5((v >> 5)  & 0x1F);
      const R = expand5((v >> 10) & 0x1F);
      let A = 255;
      if (alphaBits > 0) {
        // Use top bit as 1-bit alpha when present
        A = (v & 0x8000) ? 255 : 0;
      }
      return [R, G, B, A];
    }
    throw new Error('Unsupported truecolor bpp');
  }

  function readIndexedPixel() {
    if (bpp === 8) {
      const idx = view.getUint8(p++);
      const px = (palette && palette[idx]) || (palette && palette[cmFirst]) || [0,0,0,255];
      return px;
    } else if (bpp === 16) {
      const idx = view.getUint16(p, true); p += 2;
      const safe = Math.min(idx, (palette ? palette.length - 1 : 0));
      const px = (palette && palette[safe]) || (palette && palette[cmFirst]) || [0,0,0,255];
      return px;
    }
    throw new Error('Unsupported indexed bpp');
  }

  function readGrayPixel() {
    if (bpp === 8) {
      const v = view.getUint8(p++);
      return [v, v, v, 255];
    } else if (bpp === 16) {
      // 8-bit intensity + 8-bit alpha (little-endian)
      const intensity = view.getUint8(p++);
      const a = view.getUint8(p++);
      return [intensity, intensity, intensity, a];
    }
    throw new Error('Unsupported grayscale bpp');
  }

  function fillUncompressed(readOne) {
    for (let y = 0; y < height; y++) {
      for (let x = 0; x < width; x++) {
        const [r,g,b,a] = readOne();
        writePixel(y, x, r,g,b,a);
      }
    }
  }

  function fillRLE(readOne) {
    let x = 0, y = 0;
    const total = width * height;
    let written = 0;
    while (written < total) {
      const header = view.getUint8(p++);
      const count = (header & 0x7F) + 1;
      if (header & 0x80) {
        // run-length packet
        const px = readOne();
        for (let i = 0; i < count; i++) {
          writePixel(y, x, px[0], px[1], px[2], px[3]);
          if (++x >= width) { x = 0; y++; }
          written++;
        }
      } else {
        // raw packet
        for (let i = 0; i < count; i++) {
          const px = readOne();
          writePixel(y, x, px[0], px[1], px[2], px[3]);
          if (++x >= width) { x = 0; y++; }
          written++;
        }
      }
    }
  }

  // --- Decode by image type ---
  switch (imageType) {
    case 2:  fillUncompressed(readTruecolorPixel); break;       // truecolor
    case 10: fillRLE(readTruecolorPixel); break;                // truecolor RLE
    case 1:  fillUncompressed(readIndexedPixel); break;         // indexed
    case 9:  fillRLE(readIndexedPixel); break;                  // indexed RLE
    case 3:  fillUncompressed(readGrayPixel); break;            // grayscale
    case 11: fillRLE(readGrayPixel); break;                     // grayscale RLE
    default: throw new Error('Unsupported TGA image type');
  }

  return new ImageData(out, width, height);
}

// Hook into app namespace if present
try {
  if (typeof MERS !== "undefined" && MERS.ImageProcessor) {
    MERS.ImageProcessor.parseTGA = parseTGA;
  }
} catch (e) {}
</script>
<!-- === Patch: Right-click pan on preview (works even with tools enabled) === -->
<script>
(function(){
  function setupRightClickPan(){
    const out = document.getElementById('canvasOut');
    const paint = document.getElementById('canvasPaint');
    const targetEls = [out, paint].filter(Boolean);
    if (targetEls.length === 0) return;

    // Prevent default context menu so right-drag feels native
    targetEls.forEach(el => el.addEventListener('contextmenu', e => { e.preventDefault(); }, {passive:false}));

    targetEls.forEach(el => {
      el.addEventListener('mousedown', function(e){
        if (e.button !== 2) return; // right button only
        const st = MERS.StateManager.getState();
        let lastX = e.clientX, lastY = e.clientY;
        let active = true;

        // Change cursor feedback
        const prevCursor = el.style.cursor;
        el.style.cursor = 'grabbing';

        // While panning, suppress paint/select/bucket handlers
        e.preventDefault();
        e.stopPropagation();

        function move(ev){
          if (!active) return;
          const dx = ev.clientX - lastX;
          const dy = ev.clientY - lastY;
          lastX = ev.clientX;
          lastY = ev.clientY;
          st.panX += dx;
          st.panY += dy;

          // Redraw using current pan/zoom
          if (MERS.PreviewManager && MERS.PreviewManager.drawPreview) {
            MERS.PreviewManager.drawPreview();
          }
          if (MERS.HistogramManager && MERS.HistogramManager.drawHistogram) {
            MERS.HistogramManager.drawHistogram();
          }
        }

        function up(ev){
          active = false;
          el.style.cursor = prevCursor || '';
          window.removeEventListener('mousemove', move, true);
          window.removeEventListener('mouseup', up, true);
          // Avoid triggering a stray click after panning
          if (ev) { ev.preventDefault(); ev.stopPropagation(); }
        }

        window.addEventListener('mousemove', move, true);
        window.addEventListener('mouseup', up, true);
      }, true); // capture so we win over tool handlers
    });
  }

  if (document.readyState === 'complete' || document.readyState === 'interactive') {
    setupRightClickPan();
  } else {
    document.addEventListener('DOMContentLoaded', setupRightClickPan);
  }
})();
</script>
<!-- === Disclaimer (requested) === -->
<style>
  .mc-disclaimer {
    margin-top: 24px;
    padding: 12px 16px;
    border-top: 1px solid rgba(0,0,0,0.12);
    color: #9CA3AF;
    font-size: 12px;
    text-align: center;
    letter-spacing: .3px;
  }
</style>
<!-- === Project Link === -->
<style>
  .mc-link {
    margin-top: 12px;
    text-align: center;
    font-size: 12px;
  }
  .mc-link a { text-decoration: none; }
  .mc-link a:hover { text-decoration: underline; }
</style>
<style>
  /* Softer light blue for the project link */
  .mc-link a { color: #93C5FD; }
  .mc-link a:visited { color: #93C5FD; }
  .mc-link a:hover { color: #60A5FA; }
</style>
<div class="mc-link">
<a href="https://github.com/beachale/beachale.github.io" rel="noopener" target="_blank">https://github.com/beachale/beachale.github.io</a>
</div>
<div aria-label="Minecraft Disclaimer" class="mc-disclaimer" role="note">
  NOT AN OFFICIAL MINECRAFT TOOL. NOT APPROVED BY OR ASSOCIATED WITH MOJANG OR MICROSOFT
</div>
<script>
// PANZOOM_PATCH_START
(function(){
  function $ (sel) { return document.querySelector(sel); }

  function addWheelZoom(el){
    if (!el) return;
    el.addEventListener('wheel', function(e){
      e.preventDefault();
      const state = MERS.StateManager.getState();
      const s = Math.sign(e.deltaY);
      const before = state.zoom;
      const factor = (s > 0 ? 0.9 : 1.1);
      state.zoom = Math.max(.25, Math.min(16, state.zoom * factor));

      // Optional: zoom towards cursor (keep point under cursor roughly fixed)
      try {
        const rect = el.getBoundingClientRect();
        const cx = e.clientX - rect.left;
        const cy = e.clientY - rect.top;

        // Compute scale used by draw routines
        const st = state;
        const w = (st.src && el.id==='canvasSrc') ? st.src.width : (st.ref ? st.ref.width : 0);
        const h = (st.src && el.id==='canvasSrc') ? st.src.height : (st.ref ? st.ref.height : 0);
        const viewW = Math.min(st.anim?.w || w, w);
        const viewH = Math.min(st.anim?.h || h, h);
        const fit = Math.min(el.width / Math.max(1, viewW), el.height / Math.max(1, viewH));
        const scBefore = fit * before;
        const scAfter  = fit * state.zoom;

        // Convert cursor to image space before & after, adjust pan to keep it stable
        const dxBefore = Math.round((el.width - viewW * scBefore) / 2 + st.panX);
        const dyBefore = Math.round((el.height - viewH * scBefore) / 2 + st.panY);
        const ix = (cx - dxBefore) / scBefore;
        const iy = (cy - dyBefore) / scBefore;
        const dxAfter = Math.round((el.width - viewW * scAfter) / 2 + st.panX);
        const dyAfter = Math.round((el.height - viewH * scAfter) / 2 + st.panY);
        const cxAfter = ix * scAfter + dxAfter;
        const cyAfter = iy * scAfter + dyAfter;
        st.panX += (cx - cxAfter);
        st.panY += (cy - cyAfter);
      } catch(_){}

      const zLabel = document.getElementById('zoomVal');
      if (zLabel) zLabel.textContent = Math.round(state.zoom * 100) + '%';
      MERS.PreviewManager.drawPreview();
    }, { passive: false });
  }

  function addLeftDragPan(el){
    if (!el) return;
    let dragging = false, lastX = 0, lastY = 0;
    el.addEventListener('mousedown', function(e){
      // Only left button, and don't pan if paint tools active
      if (e.button !== 0) return;
      const paintState = MERS.StateManager.getPaintState && MERS.StateManager.getPaintState();
      if (paintState && paintState.enabled) return;
      dragging = true;
      lastX = e.clientX; lastY = e.clientY;
      e.preventDefault();
    });
    window.addEventListener('mouseup', ()=> dragging=false);
    window.addEventListener('mousemove', function(e){
      if (!dragging) return;
      const state = MERS.StateManager.getState();
      state.panX += e.clientX - lastX;
      state.panY += e.clientY - lastY;
      lastX = e.clientX; lastY = e.clientY;
      MERS.PreviewManager.drawPreview();
    });
  }

  function addRightDragPan(el){
    if (!el) return;
    // mirror existing behavior used for canvasOut/canvasPaint
    el.addEventListener('contextmenu', e => { e.preventDefault(); }, {passive:false});
    el.addEventListener('mousedown', function(e){
      if (e.button !== 2) return;
      const st = MERS.StateManager.getState();
      let lastX = e.clientX, lastY = e.clientY;
      let active = true;

      function move(ev){
        if (!active) return;
        const dx = ev.clientX - lastX;
        const dy = ev.clientY - lastY;
        lastX = ev.clientX; lastY = ev.clientY;
        st.panX += dx; st.panY += dy;
        // suppress any other handlers while panning
        ev.preventDefault(); ev.stopPropagation();
        MERS.PreviewManager.drawPreview();
      }
      function up(ev){
        active = false;
        window.removeEventListener('mousemove', move, true);
        window.removeEventListener('mouseup', up, true);
        if (ev){ ev.preventDefault(); ev.stopPropagation(); }
      }

      window.addEventListener('mousemove', move, true);
      window.addEventListener('mouseup', up, true);
    }, true); // capture so we win over other handlers
  }

  function init(){
    const ref = document.getElementById('canvasRef');
    const src = document.getElementById('canvasSrc');
    [ref, src].forEach(el => {
      addWheelZoom(el);
      addLeftDragPan(el);
      addRightDragPan(el);
    });
  }

  if (document.readyState === 'complete' || document.readyState === 'interactive') {
    init();
  } else {
    document.addEventListener('DOMContentLoaded', init);
  }
})();
// PANZOOM_PATCH_END
</script>
<!-- === Patch: RGBA channel toggles (hide from preview + exclude from TGA) === -->
<script>
(function(){
  function ready(fn){ if (document.readyState !== 'loading') fn(); else document.addEventListener('DOMContentLoaded', fn); }
  ready(function(){
    if (!window.MERS || !MERS.StateManager) return;

    // --- State: enabled flags per channel (default all true)
    const st = MERS.StateManager.getState();
    st.channelsEnabled = st.channelsEnabled || { r:true, g:true, b:true, a:true };

    // --- Helper: make a nice toggle and wire it up
    function injectToggle(groupId, chKey, labelText){
      const group = document.getElementById(groupId);
      if (!group) return;
      const header = group.previousElementSibling; // the row above the curves group
      if (!header) return;

      // Avoid adding twice
      if (header.querySelector('[data-chan-toggle="'+chKey+'"]')) return;

      const wrap = document.createElement('label');
      wrap.className = 'switch';
      wrap.setAttribute('data-chan-toggle', chKey);
      wrap.innerHTML = '<input type="checkbox" '+(st.channelsEnabled[chKey] ? 'checked' : '')+'> ' + (labelText || 'Active');
      header.appendChild(wrap);

      const input = wrap.querySelector('input');
      input.addEventListener('change', function(e){
        st.channelsEnabled[chKey] = !!e.target.checked;
        try { MERS.PreviewManager && MERS.PreviewManager.drawPreview && MERS.PreviewManager.drawPreview(); } catch(e){}
        try { MERS.HistogramManager && MERS.HistogramManager.drawHistogram && MERS.HistogramManager.drawHistogram(); } catch(e){}
      });
    }

    // Insert toggles above each curves group
    injectToggle('groupR', 'r', 'Active');
    injectToggle('groupG', 'g', 'Active');
    injectToggle('groupB', 'b', 'Active');
    injectToggle('groupA', 'a', 'Active');

    // --- Mask function used for preview/export
    function maskChannels(imgd, enabled){
      // Copy ImageData to avoid mutating the app's working buffer
      const copy = new ImageData(new Uint8ClampedArray(imgd.data), imgd.width, imgd.height);
      const d = copy.data;
      const eR = !!enabled.r, eG = !!enabled.g, eB = !!enabled.b, eA = !!enabled.a;
      for (let i=0; i<d.length; i+=4){
        if (!eR) d[i]   = 0;
        if (!eG) d[i+1] = 0;
        if (!eB) d[i+2] = 0;
        if (!eA) d[i+3] = 0;
      }
      return copy;
    }
    // Expose for other patches if needed
    MERS._maskChannelsForOutput = maskChannels;

    // --- Preview: patch renderForMode so only OUT is masked
    if (MERS.ImageProcessor && typeof MERS.ImageProcessor.renderForMode === 'function'){
      const origRender = MERS.ImageProcessor.renderForMode;
      MERS.ImageProcessor.renderForMode = function(imgd, mode, grayscale){
        try {
          const S = MERS.StateManager.getState();
          if (S && imgd === S.out && S.channelsEnabled){
            const masked = maskChannels(imgd, S.channelsEnabled);
            return origRender(masked, mode, grayscale);
          }
        } catch(e){ /* fall through */ }
        return origRender(imgd, mode, grayscale);
      };
    }

    // --- Export: override TGA export to use masked buffer
    if (MERS.ExportManager && typeof MERS.ExportManager.exportTGA === 'function' && MERS.ImageProcessor && MERS.ImageProcessor.encodeTGA){
      MERS.ExportManager.exportTGA = function(){
        const S = MERS.StateManager.getState();
        if (!S || !S.out) return;
        const masked = maskChannels(S.out, S.channelsEnabled || {r:true,g:true,b:true,a:true});
        const data = MERS.ImageProcessor.encodeTGA(masked);
        const blob = new Blob([data], { type: 'application/octet-stream' });
        const a = document.createElement('a');
        a.href = URL.createObjectURL(blob);
        const base = (document.getElementById('texName')?.textContent || 'texture').replace(/\.(png|tga)$/i, '');
        a.download = base + '_mers.tga';
        a.click();
        URL.revokeObjectURL(a.href);
      };
    }
  });
})();
</script>


<script>
// === Patch: ZIP export respects channel toggles ===
(function () {
  function ready(fn){ if (document.readyState !== 'loading') fn(); else document.addEventListener('DOMContentLoaded', fn); }
  ready(function(){
    if (!window.MERS || !MERS.StateManager || !MERS.ExportManager) return;

    // Reuse the same mask function that TGA export uses
    const mask = MERS._maskChannelsForOutput || function(imgd, enabled){
      const copy = new ImageData(new Uint8ClampedArray(imgd.data), imgd.width, imgd.height);
      const d = copy.data, e = { r:!!enabled.r, g:!!enabled.g, b:!!enabled.b, a:!!enabled.a };
      for (let i=0;i<d.length;i+=4){ if(!e.r)d[i]=0; if(!e.g)d[i+1]=0; if(!e.b)d[i+2]=0; if(!e.a)d[i+3]=0; }
      return copy;
    };

    // Override ZIP export to build files from the masked buffer
    MERS.ExportManager.exportZIP = async function(){
      const S = MERS.StateManager.getState();
      if (!S || !S.out) return;

      const enabled = S.channelsEnabled || { r:true, g:true, b:true, a:true };
      const outMasked = mask(S.out, enabled);

      const zip = new JSZip();

      async function channelPNG(imgd, ch){
        const W = imgd.width, H = imgd.height;
        const c = document.createElement('canvas'); c.width = W; c.height = H;
        const ctx = c.getContext('2d');
        const id = ctx.createImageData(W, H);
        const src = imgd.data, dst = id.data;
        for (let i=0; i<src.length; i+=4){
          const v = (ch==='r') ? src[i] : (ch==='g') ? src[i+1] : (ch==='b') ? src[i+2] : src[i+3];
          dst[i]=dst[i+1]=dst[i+2]=v; dst[i+3]=255;
        }
        ctx.putImageData(id, 0, 0);
        return new Promise(res => c.toBlob(b => res(b), 'image/png'));
      }

      const files = [['r','Red (metalness)'], ['g','Green (emissive)'], ['b','Blue (roughness)'], ['a','Alpha (subsurface)']];
      for (const [ch, name] of files){
        const blob = await channelPNG(outMasked, ch);
        zip.file(`${name}.png`, blob);
      }

      // Also include a masked TGA in the zip for parity with standalone TGA export
      const tgaBlob = new Blob([MERS.ImageProcessor.encodeTGA(outMasked)], { type: 'application/octet-stream' });
      zip.file('mers.tga', tgaBlob);

      const content = await zip.generateAsync({ type: 'blob' });
      const a = document.createElement('a');
      a.href = URL.createObjectURL(content);
      const base = (document.getElementById('texName')?.textContent || 'texture').replace(/\.(png|tga)$/i, '');
      a.download = base + '_mers.zip';
      a.click();
      URL.revokeObjectURL(a.href);
    };
  });
})();
</script>

<!-- === Patch: Copy over Reference MERS channel(s) to Your MERS (per-channel toggles) === -->
<script>
(function(){
  function ready(fn){ if (document.readyState !== 'loading') fn(); else document.addEventListener('DOMContentLoaded', fn); }
  ready(function(){
    if (!window.MERS || !MERS.StateManager || !MERS.Core) return;

    // --- State: add copyRefChannels flags (default all OFF)
    const st = MERS.StateManager.getState();
    st.copyRefChannels = st.copyRefChannels || { r:false, g:false, b:false, a:false };

    // --- Inject UI above the Reference TGA canvas
    (function injectUI(){
      const wrapRef = document.getElementById('wrapRef');
      const canvasRef = document.getElementById('canvasRef');
      if (!wrapRef || !canvasRef) return;
      if (document.getElementById('copyRefRow')) return; // avoid dup

      const row = document.createElement('div');
      row.className = 'row';
      row.id = 'copyRefRow';
      row.style.cssText = 'align-items:center; gap:8px; padding:6px 8px; border-bottom:1px dashed var(--border);';
      row.innerHTML = `
        <span class="muted" style="font-size:12px; white-space:nowrap;">Copy over Reference MERS channel to Your MERS:</span>
        <label class="switch" title="Copy Reference ➜ Your: R (Metalness)"><input id="copyRef_r" type="checkbox"/><span>R</span></label>
        <label class="switch" title="Copy Reference ➜ Your: G (Emissive)"><input id="copyRef_g" type="checkbox"/><span>G</span></label>
        <label class="switch" title="Copy Reference ➜ Your: B (Roughness)"><input id="copyRef_b" type="checkbox"/><span>B</span></label>
        <label class="switch" title="Copy Reference ➜ Your: A (Subsurface)"><input id="copyRef_a" type="checkbox"/><span>A</span></label>
      `;
      wrapRef.insertBefore(row, canvasRef);
    })();

    // --- Wire up UI
    function syncUI(){
      const s = MERS.StateManager.getState();
      ['r','g','b','a'].forEach(ch => {
        const el = document.getElementById('copyRef_' + ch);
        if (!el) return;
        el.checked = !!(s.copyRefChannels && s.copyRefChannels[ch]);
        // Disable when no reference loaded
        el.disabled = !s.ref;
        el.parentElement.style.opacity = el.disabled ? 0.5 : 1;
      });
    }
    function bindUI(){
      ['r','g','b','a'].forEach(ch => {
        const el = document.getElementById('copyRef_' + ch);
        if (!el) return;
        el.addEventListener('change', function(){
          const s = MERS.StateManager.getState();
          s.copyRefChannels = s.copyRefChannels || { r:false, g:false, b:false, a:false };
          s.copyRefChannels[ch] = !!this.checked;
          // Ensure ref is resampled for current src size
          if (s.src && s.ref) {
            try { MERS.Core.rebuildRefColorMap(); } catch(e){}
          }
          MERS.Core.recompute();
        });
      });
    }
    syncUI(); bindUI();

    // --- Keep UI in sync when ref loads / controls update
    if (MERS.UIManager && typeof MERS.UIManager.updateRefControls === 'function'){
      const origUpd = MERS.UIManager.updateRefControls;
      MERS.UIManager.updateRefControls = function(){
        try { origUpd.apply(this, arguments); } finally { syncUI(); }
      };
    }

    // --- Patch Core.recompute to copy channels from ref BEFORE painting
    if (MERS.Core && typeof MERS.Core.recompute === 'function'){
      const origRecompute = MERS.Core.recompute;
      MERS.Core.recompute = function(){
        // First run normal pipeline
        origRecompute();

        try {
          const s = MERS.StateManager.getState();
          if (!s || !s.out || !s.ref || !s.src) return;
          const flags = s.copyRefChannels || {r:false,g:false,b:false,a:false};
          if (!flags.r && !flags.g && !flags.b && !flags.a) return;

          // Ensure ref is resampled to match out size
          if (!s.refRes || s.refRes.width !== s.src.width || s.refRes.height !== s.src.height) {
            if (MERS.ImageProcessor && MERS.ImageProcessor.resampleImageData) {
              s.refRes = MERS.ImageProcessor.resampleImageData(s.ref, s.src.width, s.src.height);
            } else {
              return;
            }
          }

          const out = s.out.data;
          const ref = s.refRes.data;
          const N = out.length;
          for (let i=0; i<N; i+=4){
            if (flags.r) out[i]   = ref[i];
            if (flags.g) out[i+1] = ref[i+1];
            if (flags.b) out[i+2] = ref[i+2];
            if (flags.a) out[i+3] = ref[i+3];
          }

          // Re-apply paint overlays so brush/bucket stay on top
          try { MERS.PaintTool && MERS.PaintTool.applyPaintOnOut && MERS.PaintTool.applyPaintOnOut(); } catch(e){}
          // Redraw UI
          try { MERS.PreviewManager && MERS.PreviewManager.drawPreview && MERS.PreviewManager.drawPreview(); } catch(e){}
          try { MERS.HistogramManager && MERS.HistogramManager.drawHistogram && MERS.HistogramManager.drawHistogram(); } catch(e){}
        } catch(e){
          console.warn('copyRefChannels patch error:', e);
        }
      };
    }

  }); // ready
})();
</script>


<!-- === Patch 2: Move copy-channel toggles into Reference header (above canvas) === -->
<script>
(function(){
  function ready(fn){ if (document.readyState !== 'loading') fn(); else document.addEventListener('DOMContentLoaded', fn); }
  ready(function(){
    if (!window.MERS || !MERS.StateManager) return;

    const st = MERS.StateManager.getState();
    st.copyRefChannels = st.copyRefChannels || { r:false, g:false, b:false, a:false };

    // Remove previous inline row if it exists (so controls aren't inside the canvas area)
    const oldRow = document.getElementById('copyRefRow');
    if (oldRow && oldRow.parentElement) oldRow.parentElement.removeChild(oldRow);

    // Inject into the existing Reference header toolbar to ensure it's truly "above the canvas"
    const wrapRef = document.getElementById('wrapRef');
    const toolbar = wrapRef ? wrapRef.querySelector('.canvasHeader .toolbar') : null;
    if (toolbar && !document.getElementById('copyRefToolbarGroup')){
      const group = document.createElement('div');
      group.id = 'copyRefToolbarGroup';
      group.className = 'toolbarGroup';
      group.style.cssText = 'display:flex;align-items:center;gap:8px;flex-wrap:wrap;';
      group.innerHTML = `
        <span class="muted" style="font-size:12px;">Copy over Reference MERS channel to Your MERS:</span>
        <label class="switch" title="Copy Reference ➜ Your: R (Metalness)"><input id="copyRef_r" type="checkbox"/><span>R</span></label>
        <label class="switch" title="Copy Reference ➜ Your: G (Emissive)"><input id="copyRef_g" type="checkbox"/><span>G</span></label>
        <label class="switch" title="Copy Reference ➜ Your: B (Roughness)"><input id="copyRef_b" type="checkbox"/><span>B</span></label>
        <label class="switch" title="Copy Reference ➜ Your: A (Subsurface)"><input id="copyRef_a" type="checkbox"/><span>A</span></label>
      `;
      toolbar.appendChild(group);
    }

    function syncUI(){
      const s = MERS.StateManager.getState();
      ['r','g','b','a'].forEach(ch => {
        const el = document.getElementById('copyRef_' + ch);
        if (!el) return;
        el.checked = !!(s.copyRefChannels && s.copyRefChannels[ch]);
        el.disabled = !s.ref;
        if (el.parentElement) el.parentElement.style.opacity = el.disabled ? 0.5 : 1;
      });
    }
    function bindUI(){
      ['r','g','b','a'].forEach(ch => {
        const el = document.getElementById('copyRef_' + ch);
        if (!el) return;
        el.onchange = function(){
          const s = MERS.StateManager.getState();
          s.copyRefChannels = s.copyRefChannels || { r:false, g:false, b:false, a:false };
          s.copyRefChannels[ch] = !!this.checked;
          try { if (s.src && s.ref && MERS.Core.rebuildRefColorMap) MERS.Core.rebuildRefColorMap(); } catch(e){}
          MERS.Core.recompute();
        };
      });
    }

    // Hook into UI refreshes
    if (MERS.UIManager && typeof MERS.UIManager.updateRefControls === 'function'){
      const origUpd = MERS.UIManager.updateRefControls;
      if (!MERS.__copyRefToolbarSyncPatched){
        MERS.UIManager.updateRefControls = function(){
          try { origUpd.apply(this, arguments); } finally { syncUI(); }
        };
        MERS.__copyRefToolbarSyncPatched = true;
      }
    }

    // Ensure recompute patch applied only once (the earlier patch might already do this)
    if (MERS.Core && !MERS.__copyRefChannelsPatched){
      const origRecompute = MERS.Core.recompute;
      MERS.Core.recompute = function(){
        origRecompute();
        try {
          const s = MERS.StateManager.getState();
          if (!s || !s.out || !s.ref || !s.src) return;
          const f = s.copyRefChannels || {r:false,g:false,b:false,a:false};
          if (!f.r && !f.g && !f.b && !f.a) return;
          // Resample ref to src size if helper exists
          if (!s.refRes || s.refRes.width !== s.src.width || s.refRes.height !== s.src.height) {
            if (MERS.ImageProcessor && MERS.ImageProcessor.resampleImageData) {
              s.refRes = MERS.ImageProcessor.resampleImageData(s.ref, s.src.width, s.src.height);
            } else { return; }
          }
          const out = s.out.data, ref = s.refRes.data;
          for (let i=0;i<out.length;i+=4){
            if (f.r) out[i]   = ref[i];
            if (f.g) out[i+1] = ref[i+1];
            if (f.b) out[i+2] = ref[i+2];
            if (f.a) out[i+3] = ref[i+3];
          }
          if (MERS.PaintTool && MERS.PaintTool.applyPaintOnOut) MERS.PaintTool.applyPaintOnOut();
          if (MERS.PreviewManager && MERS.PreviewManager.drawPreview) MERS.PreviewManager.drawPreview();
          if (MERS.HistogramManager && MERS.HistogramManager.drawHistogram) MERS.HistogramManager.drawHistogram();
        } catch(e){ console.warn('copyRefChannels (header) error:', e); }
      };
      MERS.__copyRefChannelsPatched = true;
    }

    // Initial setup
    syncUI(); bindUI();
  });
})();
</script>


<!-- === Patch 3: Place copy-channel toggles inside the top control panel (RIGHT -> panel -> row) === -->
<script>
(function(){
  function ready(fn){ if (document.readyState !== 'loading') fn(); else document.addEventListener('DOMContentLoaded', fn); }
  ready(function(){
    if (!window.MERS || !MERS.StateManager) return;

    // Clean up any older placements of this control
    ['copyRefRow','copyRefToolbarGroup','copyRefTopGroup'].forEach(id => {
      const el = document.getElementById(id);
      if (el && el.parentElement) el.parentElement.removeChild(el);
    });

    const s = MERS.StateManager.getState();
    s.copyRefChannels = s.copyRefChannels || { r:false, g:false, b:false, a:false };

    // Find the row with Use ref map / Match colors / Grayscale
    const useRef = document.getElementById('useRefMapTop');
    const row = useRef ? useRef.closest('.row') : null;
    if (!row) return;

    // Build the compact group to live inside the panel row
    const group = document.createElement('div');
    group.id = 'copyRefTopGroup';
    group.className = 'row';
    group.style.cssText = 'gap:10px; align-items:center; margin-left:12px;';

    // Label
    const label = document.createElement('span');
    label.className = 'muted';
    label.style.cssText = 'font-size:12px; white-space:nowrap;';
    label.textContent = 'Copy over Reference MERS channel to Your MERS:';
    group.appendChild(label);

    // Channel toggles
    ['r','g','b','a'].forEach(ch => {
      const lab = document.createElement('label');
      lab.className = 'switch';
      lab.title = 'Copy Reference → Your: ' + ch.toUpperCase();
      const input = document.createElement('input');
      input.type = 'checkbox';
      input.id = 'copyRef_' + ch;
      const span = document.createElement('span');
      span.textContent = ch.toUpperCase();
      lab.appendChild(input);
      lab.appendChild(span);
      group.appendChild(lab);
    });

    // Insert after the ref-matching select (if present), otherwise after the Use ref map switch
    const refSel = document.getElementById('refMatchTop');
    if (refSel && refSel.parentElement === row) {
      row.insertBefore(group, refSel.nextSibling);
    } else {
      // fallback: append at end of row
      row.appendChild(group);
    }

    function syncUI(){
      const st = MERS.StateManager.getState();
      ['r','g','b','a'].forEach(ch => {
        const el = document.getElementById('copyRef_' + ch);
        if (!el) return;
        el.checked = !!(st.copyRefChannels && st.copyRefChannels[ch]);
        // disabled if no ref is loaded
        el.disabled = !st.ref;
        if (el.parentElement) el.parentElement.style.opacity = el.disabled ? 0.5 : 1;
      });
    }
    function bindUI(){
      ['r','g','b','a'].forEach(ch => {
        const el = document.getElementById('copyRef_' + ch);
        if (!el) return;
        el.addEventListener('change', function(){
          const st = MERS.StateManager.getState();
          st.copyRefChannels = st.copyRefChannels || { r:false, g:false, b:false, a:false };
          st.copyRefChannels[ch] = !!this.checked;
          try { if (st.src && st.ref && MERS.Core.rebuildRefColorMap) MERS.Core.rebuildRefColorMap(); } catch(e){}
          if (MERS.Core && MERS.Core.recompute) MERS.Core.recompute();
        });
      });
    }

    // Hook into ref control updates so enable/disable follows ref load state
    if (MERS.UIManager && typeof MERS.UIManager.updateRefControls === 'function' && !MERS.__copyRefTopSyncPatched){
      const orig = MERS.UIManager.updateRefControls;
      MERS.UIManager.updateRefControls = function(){
        try { orig.apply(this, arguments); } finally { syncUI(); }
      };
      MERS.__copyRefTopSyncPatched = true;
    }

    // Ensure recompute patch is present only once
    if (MERS.Core && !MERS.__copyRefChannelsPatched){
      const base = MERS.Core.recompute;
      MERS.Core.recompute = function(){
        base();
        try {
          const st = MERS.StateManager.getState();
          if (!st || !st.out || !st.ref || !st.src) return;
          const f = st.copyRefChannels || {r:false,g:false,b:false,a:false};
          if (!f.r && !f.g && !f.b && !f.a) return;
          if (!st.refRes || st.refRes.width !== st.src.width || st.refRes.height !== st.src.height) {
            if (MERS.ImageProcessor && MERS.ImageProcessor.resampleImageData) {
              st.refRes = MERS.ImageProcessor.resampleImageData(st.ref, st.src.width, st.src.height);
            } else { return; }
          }
          const out = st.out.data, ref = st.refRes.data;
          for (let i=0;i<out.length;i+=4){
            if (f.r) out[i]   = ref[i];
            if (f.g) out[i+1] = ref[i+1];
            if (f.b) out[i+2] = ref[i+2];
            if (f.a) out[i+3] = ref[i+3];
          }
          if (MERS.PaintTool && MERS.PaintTool.applyPaintOnOut) MERS.PaintTool.applyPaintOnOut();
          if (MERS.PreviewManager && MERS.PreviewManager.drawPreview) MERS.PreviewManager.drawPreview();
          if (MERS.HistogramManager && MERS.HistogramManager.drawHistogram) MERS.HistogramManager.drawHistogram();
        } catch(e){ console.warn('copyRefChannels (top panel) error:', e); }
      };
      MERS.__copyRefChannelsPatched = true;
    }

    syncUI();
    bindUI();
  });
})();
</script>


<script>
/* ===========================
   MERS.GLViewer – WebGL2 cube (v3)
   - Base/albedo = original image file (not the zoomed preview canvas)
   - PBR MERS map = built from MERS internal state at full-res (no letterbox)
   - Channels: R=Metalness, G=Emissive, B=Roughness, A=SSS
   - One directional light angled above
   - Re-syncs on recompute & file load only
*/
(function () {
  const $ = (s) => document.querySelector(s);

  // --- 1) Inject a panel with a GL canvas into the right column ----------------
  const rightCol = document.querySelector('.right') || document.body;
  const panel = document.createElement('div');
  panel.className = 'panel';
  panel.innerHTML = `
    <div class="row" style="justify-content:space-between">
      <span class="chip">Experimental 3D Viewer (WebGL2)</span>
      <div class="row" style="gap:8px;">
        <button id="gl_pop" class="chip" style="cursor:pointer;font-weight:700;text-transform:uppercase;">⤢ Pop‑out</button>
        <label class="switch"><input id="gl_spin" type="checkbox"> Auto-rotate</label>
      </div>
    </div>
    <div class="canvasWrap" id="wrap3D" style="height: 384px;">
      <canvas id="glCanvas" class="preview" width="640" height="384"></canvas>
    </div>
    <div class="row" style="gap:12px;margin-top:8px;align-items:center;flex-wrap:wrap">
      <label class="chip">Geometry
        <select id="gl_geom" style="margin-left:8px; padding:2px 6px;">
          <option value="cube">Cube</option>
          <option value="plane">Vertical Plane</option>
          <option value="xplane">X‑Planes</option>
        </select>
        <div class="muted" style="margin-top:6px;max-width:520px">Light settings will affect look of mers values. Future update will match in-game sun</div>

      </label>

      <label class="chip">Light Intensity
        <input type="range" id="gl_light_intensity" min="0" max="3" step="0.01" value="1.6" style="width:200px;margin-left:8px">
      </label>
      <span id="gl_li_val" class="muted">1.60</span>
      <label class="chip">Light Size
        <input type="range" id="gl_light_size" min="0" max="0.5" step="0.001" value="0.12" style="width:200px;margin-left:8px">
      </label>
      <span id="gl_ls_val" class="muted">0.12</span>
      <label class="chip">Light Height
        <input type="range" id="gl_light_elev" min="0" max="89" step="1" value="60" style="width:200px;margin-left:8px">
      </label>
      <span id="gl_le_val" class="muted">60°</span>
      <label class="chip">Side Fill
        <input type="range" id="gl_side_fill" min="0" max="0.6" step="0.01" value="0.25" style="width:200px;margin-left:8px">
      </label>
      <span id="gl_sf_val" class="muted">0.25</span>
      <label class="chip">Light Azimuth
        <input type="range" id="gl_light_azim" min="0" max="360" step="1" value="31" style="width:200px;margin-left:8px">
      </label>
      <span id="gl_la_val" class="muted">31°</span>
      <label class="chip">Albedo Lock
        <input type="checkbox" id="gl_albedo_lock" checked style="margin-left:8px">
      </label>
      <label class="chip">Point Light
        <input type="checkbox" id="gl_light_point" style="margin-left:8px">
      </label>
      <label class="chip">Light Distance
        <input type="range" id="gl_light_dist" min="0.5" max="10" step="0.01" value="2.0" style="width:200px;margin-left:8px">
      </label>
      <span id="gl_ld_val" class="muted">2.00</span>
      <label class="chip">Light Y
        <input type="range" id="gl_light_y" min="-3" max="3" step="0.01" value="1.50" style="width:200px;margin-left:8px">
      </label>
      <span id="gl_ly_val" class="muted">1.50</span>
    </div>
  `;
  // Prefer to place next to the Original texture (wrapSrc)
const wrapSrc = document.getElementById('wrapSrc') || (function(){ const c=document.getElementById('canvasSrc'); return c? c.parentElement : null; })();
const dockParent = wrapSrc ? wrapSrc.parentNode : rightCol;
if (wrapSrc) {
  wrapSrc.insertAdjacentElement('afterend', panel);
} else {
  dockParent.appendChild(panel);
}


  // Restore/persist slider & dropdown values
  function persistRange(id, key, def){
    const el = document.getElementById(id);
    if (!el) return def;
    const saved = localStorage.getItem(key);
    if (saved !== null) { el.value = saved; }
    el.addEventListener('input', ()=> localStorage.setItem(key, el.value));
    return parseFloat(el.value || def);
  }
  function persistSelect(id, key, def){
    const el = document.getElementById(id);
    if (!el) return def;
    const saved = localStorage.getItem(key);
    if (saved) { el.value = saved; }
    el.addEventListener('change', ()=> localStorage.setItem(key, el.value));
    return el.value || def;
  }
  function persistCheck(id, key, defBool){
  const el = document.getElementById(id);
  if (!el) return defBool;
  const saved = localStorage.getItem(key);
  if (saved !== null) { el.checked = (saved === '1'); }
  else { el.checked = !!defBool; }
  el.addEventListener('change', ()=> localStorage.setItem(key, el.checked ? '1':'0'));
  return !!el.checked;
}

  // Initialize geometry saved value into the dropdown
  persistSelect('gl_geom', 'glGeom', 'cube');
  persistCheck('gl_light_point','glLP', false);
  persistRange('gl_light_dist','glLD','2.0');
  persistRange('gl_light_y','glLY','1.5');
  persistCheck('gl_albedo_lock','glAL', true);

  // Initialize sliders with saved values
  persistRange('gl_light_intensity','glLI','1.6');
  persistRange('gl_light_size','glLS','0.12');
  persistRange('gl_light_elev','glLE','60');
  persistRange('gl_side_fill','glSF','0.25');
  persistRange('gl_light_azim','glLA','31');


  // Insert floating panel styles
  (function(){
    const css = `
      .gl-float{position:fixed; left:24px; top:24px; width:640px; max-width:90vw; z-index:9999; box-shadow:0 12px 40px rgba(0,0,0,.45);}
      .gl-drag-handle{cursor:move;}
      .gl-grabbing{cursor:grabbing !important;}
    `;
    const st=document.createElement('style'); st.textContent=css; document.head.appendChild(st);
  })();

  // --- 2) Minimal math helpers -------------------------------------------------
  function mat4_perspective(out, fovy, aspect, near, far) {
    const f = 1.0 / Math.tan(fovy / 2), nf = 1 / (near - far);
    out[0]=f/aspect; out[1]=0; out[2]=0; out[3]=0;
    out[4]=0; out[5]=f; out[6]=0; out[7]=0;
    out[8]=0; out[9]=0; out[10]=(far+near)*nf; out[11]=-1;
    out[12]=0; out[13]=0; out[14]=(2*far*near)*nf; out[15]=0;
    return out;
  }
  function mat4_mul(a,b){
    const r=new Float32Array(16);
    for(let i=0;i<4;i++){
      for(let j=0;j<4;j++){
        r[i*4+j]=a[i*4+0]*b[0*4+j]+a[i*4+1]*b[1*4+j]+a[i*4+2]*b[2*4+j]+a[i*4+3]*b[3*4+j];
      }
    }
    return r;
  }
  function mat4_identity(){
    const m=new Float32Array(16);
    m[0]=1;m[5]=1;m[10]=1;m[15]=1;
    return m;
  }
  function mat4_translate(m, v){
    const t=mat4_identity();
    t[12]=v[0]; t[13]=v[1]; t[14]=v[2];
    return mat4_mul(m,t);
  }
  function mat4_rotateY(m, a){
    const c=Math.cos(a), s=Math.sin(a);
    const r=new Float32Array(16);
    r.set([c,0,-s,0,  0,1,0,0,  s,0,c,0,  0,0,0,1]);
    return mat4_mul(m,r);
  }
  function mat4_rotateX(m, a){
    const c=Math.cos(a), s=Math.sin(a);
    const r=new Float32Array(16);
    r.set([1,0,0,0,  0,c,s,0,  0,-s,c,0,  0,0,0,1]);
    return mat4_mul(m,r);
  }
  function vec3_norm(v){
    const l=Math.hypot(v[0],v[1],v[2]); return l? [v[0]/l,v[1]/l,v[2]/l]:[0,0,0];
  }

  // --- 3) WebGL2 setup ---------------------------------------------------------
  const canvas = document.getElementById('glCanvas');
  const gl = canvas.getContext('webgl2', { antialias: true, alpha: false });
  if (!gl) {
    const wrap = document.getElementById('wrap3D');
    wrap.innerHTML = '<div style="padding:12px" class="muted">WebGL2 not available.</div>';
    return;
  }

  // Shaders (PBR-ish single light; NO tint overlay)
  const VERT = `#version 300 es
  precision highp float;
  layout(location=0) in vec3 aPos;
  layout(location=1) in vec3 aNrm;
  layout(location=2) in vec2 aUV;
  uniform mat4 uProj, uView, uModel;
  out vec3 vN;
  out vec3 vWPos;
  out vec2 vUV;
  void main(){
    vec4 wpos = uModel * vec4(aPos,1.0);
    vWPos = wpos.xyz;
    vN = mat3(uModel) * aNrm;
    vUV = aUV;
    gl_Position = uProj * uView * wpos;
  }`;

  const FRAG = `#version 300 es
  precision highp float;
  in vec3 vN;
  in vec3 vWPos;
  in vec2 vUV;
  out vec4 frag;

  uniform sampler2D uAlbedo; // original texture (sRGB)
  uniform sampler2D uMERS;   // R=Metalness, G=Emissive, B=Roughness, A=SSS
  uniform vec3 uCamPos;
  uniform vec3 uLightDir;    // normalized
  uniform float uLightIntensity;
  uniform float uLightSize;
  uniform float uAmbient;
  uniform float uSideFill;
  uniform float uLightKind; // 0=Directional, 1=Point
  uniform float uLightDistance;
  uniform float uLightAtten;
  uniform vec3  uLightPos;
  uniform float uAlbedoLock;

  // sRGB <-> Linear helpers
  vec3 toLinear(vec3 c){ return pow(c, vec3(2.2)); }
  vec3 toSRGB(vec3 c){ return pow(max(c, vec3(0.0)), vec3(1.0/2.2)); }

  // GGX helpers
  float D_GGX(float NoH, float a){
    float a2 = a*a;
    float d = (NoH*NoH)*(a2-1.0)+1.0;
    return a2 / (3.14159*d*d + 1e-7);
  }
  float V_SmithGGXCorrelated(float NoV, float NoL, float a){
    float a2 = a*a;
    float gv = NoL*sqrt((NoV-NoV*a2)*NoV + a2);
    float gl = NoV*sqrt((NoL-NoL*a2)*NoL + a2);
    return 0.5 / (gv+gl + 1e-7);
  }
  vec3 F_Schlick(float VoH, vec3 F0){
    return F0 + (1.0 - F0)*pow(1.0 - VoH, 5.0);
  }

  void main(){
    vec3 N = normalize(vN);
    vec3 V = normalize(uCamPos - vWPos);
    vec3 L; float att = 1.0;
    if (uLightKind > 0.5) {
      vec3 toL = uLightPos - vWPos;
      float r = length(toL);
      L = toL / max(r, 1e-6);
      att = 1.0 / (1.0 + uLightAtten * r * r);
    } else {
      L = normalize(-uLightDir);
    }
    vec3 H = normalize(V+L);

    vec4 albedo_srgba = texture(uAlbedo, vUV);
    if (albedo_srgba.a < 0.01) { discard; }
    vec3 albedo = toLinear(albedo_srgba.rgb);

    vec4 mers = texture(uMERS, vUV);
    float metal = clamp(mers.r, 0.0, 1.0);
    float emissiveStrength = clamp(mers.g, 0.0, 1.0);
    float rough = clamp(mers.b, 0.04, 1.0);
    float sss = clamp(mers.a, 0.0, 1.0);

    // PBR core
    float NoL = clamp(dot(N,L), 0.0, 1.0);
    float NoV = clamp(dot(N,V), 0.0, 1.0);
    float NoH = clamp(dot(N,H), 0.0, 1.0);
    float VoH = clamp(dot(V,H), 0.0, 1.0);

    // Diffuse/spec setup
    vec3 baseDiffuse = albedo; // unmodified albedo (linear)
    vec3 diffuseColor = mix(baseDiffuse, baseDiffuse * (1.0 - metal), step(0.5, 1.0 - uAlbedoLock));
    // Fresnel base reflectance: physical uses albedo for metals; lock mode uses neutral high F0
    vec3 F0_phys = mix(vec3(0.04), albedo, metal);
    vec3 F0_lock = mix(vec3(0.04), vec3(0.9), metal);
    vec3 F0 = mix(F0_phys, F0_lock, uAlbedoLock);

    // Microfacet terms
    float a = (rough + uLightSize);
    a = max(0.001, a*a);
    float D = D_GGX(NoH, a);
    float Vg = V_SmithGGXCorrelated(NoV, NoL, a);
    vec3  F = F_Schlick(VoH, F0);
    vec3  spec = (D * Vg) * F;

    // Simple wrap lighting for "SSS" feel
    float wrap = mix(0.0, 0.5, sss);
    float NoL_wrap = clamp((dot(N,L) + wrap) / (1.0 + wrap), 0.0, 1.0);

    vec3 Lo = (uLightIntensity * att) * ( (diffuseColor/3.14159) * NoL_wrap + spec * NoL );

    // Emissive (use albedo color scaled by G)
    vec3 emissive = albedo * emissiveStrength;

    float side = (abs(N.x)+abs(N.z))*0.5;
    vec3 fill = diffuseColor * (uAmbient + uSideFill * side);
    vec3 color = Lo + emissive + fill;

    frag = vec4( toSRGB(color), 1.0 );
  }`;

  function makeShader(type, src){
    const s = gl.createShader(type);
    gl.shaderSource(s, src);
    gl.compileShader(s);
    if(!gl.getShaderParameter(s, gl.COMPILE_STATUS)){
      console.error(gl.getShaderInfoLog(s));
      throw new Error('Shader compile error');
    }
    return s;
  }
  function makeProgram(vs, fs){
    const p = gl.createProgram();
    gl.attachShader(p, vs);
    gl.attachShader(p, fs);
    gl.linkProgram(p);
    if(!gl.getProgramParameter(p, gl.LINK_STATUS)){
      console.error(gl.getProgramInfoLog(p));
      throw new Error('Program link error');
    }
    return p;
  }

  const prog = makeProgram(makeShader(gl.VERTEX_SHADER, VERT), makeShader(gl.FRAGMENT_SHADER, FRAG));
  gl.useProgram(prog);

  // Locations
  const loc = {
    uProj: gl.getUniformLocation(prog, 'uProj'),
    uView: gl.getUniformLocation(prog, 'uView'),
    uModel: gl.getUniformLocation(prog, 'uModel'),
    uAlbedo: gl.getUniformLocation(prog, 'uAlbedo'),
    uMERS: gl.getUniformLocation(prog, 'uMERS'),
    uCamPos: gl.getUniformLocation(prog, 'uCamPos'),
    uLightDir: gl.getUniformLocation(prog, 'uLightDir'),
    uLightIntensity: gl.getUniformLocation(prog, 'uLightIntensity'),
    uLightSize: gl.getUniformLocation(prog, 'uLightSize'),
    uAmbient: gl.getUniformLocation(prog, 'uAmbient'),
    uSideFill: gl.getUniformLocation(prog, 'uSideFill'),
    uLightKind: gl.getUniformLocation(prog, 'uLightKind'),
    uLightDistance: gl.getUniformLocation(prog, 'uLightDistance'),
    uLightAtten: gl.getUniformLocation(prog, 'uLightAtten'),
    uLightPos: gl.getUniformLocation(prog, 'uLightPos'),
    uAlbedoLock: gl.getUniformLocation(prog, 'uAlbedoLock')
  };

  
  // --- 4) Geometry (dynamic) ---------------------------------------------------
  let indexCount = 0;
  let vao = null, ebo = null, vboPos = null, vboNrm = null, vboUV = null;

  function initBuffers(){
    vao = gl.createVertexArray();
    gl.bindVertexArray(vao);
    vboPos = gl.createBuffer();
    vboNrm = gl.createBuffer();
    vboUV  = gl.createBuffer();
    ebo    = gl.createBuffer();
    gl.enableVertexAttribArray(0);
    gl.enableVertexAttribArray(1);
    gl.enableVertexAttribArray(2);
  }

  function setGeometry(mode){
    // Build geometry arrays
    let P=[], N=[], UV=[], I=[];

    function pushQuad(px,py,pz, nx,ny,nz, ux,uy,uz, vx,vy,vz){
      // 0..1 UV quad
      const base = P.length/3;
      P.push(px,py,pz,  px+ux,py+uy,pz+uz,  px+ux+vx,py+uy+vy,pz+uz+vz,  px+vx,py+vy,pz+vz);
      for(let i=0;i<4;i++){ N.push(nx,ny,nz); }
      UV.push(0,1, 1,1, 1,0, 0,0);
      I.push(base+0, base+1, base+2, base+0, base+2, base+3);
    }

    if (mode === 'cube'){
      // unit cube centered at origin (size 2)
      pushQuad(-1,-1, 1,  0,0,1,   2,0,0,  0,2,0);   // front
      pushQuad( 1,-1,-1, 0,0,-1,  -2,0,0,  0,2,0);  // back
      pushQuad(-1,-1,-1,-1,0,0,   0,0,2,  0,2,0);   // left
      pushQuad( 1,-1, 1,  1,0,0,   0,0,-2, 0,2,0);  // right
      pushQuad(-1, 1, 1,  0,1,0,   2,0,0,  0,0,-2); // top
      pushQuad(-1,-1,-1, 0,-1,0,   2,0,0,  0,0, 2); // bottom
    } else if (mode === 'plane'){
      // Single vertical plane facing +Z, size 2x2 centered at origin
      pushQuad(-1,-1,0, 0,0,1, 2,0,0, 0,2,0);
      // duplicate back face with flipped normal so both sides shade
      const base = P.length/3;
      P.push(-1,-1,0,  1,-1,0,  1, 1,0,  -1, 1,0);
      for(let i=0;i<4;i++){ N.push(0,0,-1); }
      UV.push(0,1,1,1,1,0,0,0);
      I.push(base+0, base+1, base+2, base+0, base+2, base+3);
    } else { // 'xplane'
      // Two crossing vertical planes (X), both double-sided
      const addPlane = (angle)=>{
        const c=Math.cos(angle), s=Math.sin(angle);
        // plane along rotated X axis
        const p00=[-1*c,-1, 1*s], p10=[1*c,-1,-1*s], p11=[1*c,1,-1*s], p01=[-1*c,1,1*s];
        const base = P.length/3;
        P.push(...p00, ...p10, ...p11, ...p01);
        for(let i=0;i<4;i++){ N.push(0,0,1); }
        UV.push(0,1,1,1,1,0,0,0);
        I.push(base+0,base+1,base+2, base+0,base+2,base+3);
        // back side
        const base2 = P.length/3;
        P.push(...p00, ...p01, ...p11, ...p10);
        for(let i=0;i<4;i++){ N.push(0,0,-1); }
        UV.push(0,1,0,0,1,0,1,1);
        I.push(base2+0,base2+1,base2+2, base2+0,base2+2,base2+3);
      };
      addPlane(0);
      addPlane(Math.PI/2);
    }

    const positions = new Float32Array(P);
    const normals   = new Float32Array(N);
    const uvs       = new Float32Array(UV);
    const idx       = new Uint16Array(I);

    gl.bindVertexArray(vao);

    gl.bindBuffer(gl.ARRAY_BUFFER, vboPos);
    gl.bufferData(gl.ARRAY_BUFFER, positions, gl.STATIC_DRAW);
    gl.vertexAttribPointer(0, 3, gl.FLOAT, false, 0, 0);

    gl.bindBuffer(gl.ARRAY_BUFFER, vboNrm);
    gl.bufferData(gl.ARRAY_BUFFER, normals, gl.STATIC_DRAW);
    gl.vertexAttribPointer(1, 3, gl.FLOAT, false, 0, 0);

    gl.bindBuffer(gl.ARRAY_BUFFER, vboUV);
    gl.bufferData(gl.ARRAY_BUFFER, uvs, gl.STATIC_DRAW);
    gl.vertexAttribPointer(2, 2, gl.FLOAT, false, 0, 0);

    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, ebo);
    gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, idx, gl.STATIC_DRAW);

    indexCount = idx.length;
  }

  initBuffers();
  // Set initial geometry from dropdown and react to changes
  (function(){
    const sel = document.getElementById('gl_geom');
    if (sel){
      setGeometry(sel.value || 'cube');
      // If no saved preference, default to point light for planes
      const lpSaved = localStorage.getItem('glLP');
      if (lpSaved === null){
        const mode = sel.value || 'cube';
        const chk = document.getElementById('gl_light_point');
        const distEl = document.getElementById('gl_light_dist');
        if (chk){ chk.checked = (mode !== 'cube'); localStorage.setItem('glLP', chk.checked ? '1':'0'); }
        if (distEl && mode !== 'cube'){ distEl.value = '2.0'; localStorage.setItem('glLD', distEl.value); }
      }
      sel.addEventListener('change', (e)=> setGeometry(e.target.value));
    } else {
      setGeometry('cube');
    }
  })();
// --- 5) Textures: lock albedo to original file; build MERS from state -------
  function makeTex() {
    const t = gl.createTexture();
    gl.bindTexture(gl.TEXTURE_2D, t);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR_MIPMAP_LINEAR);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
    return t;
  }
  const texAlbedo = makeTex();
  const texMERS   = makeTex();

  // Force nearest-neighbor for albedo (pixel-art style)
  gl.bindTexture(gl.TEXTURE_2D, texAlbedo);
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);

  // Force nearest-neighbor for MERS as well
  gl.bindTexture(gl.TEXTURE_2D, texMERS);
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);

  async function setAlbedoFromFile(file){
    try{
      const bitmap = await createImageBitmap(file);
      gl.bindTexture(gl.TEXTURE_2D, texAlbedo);
      gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, false);
      gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, bitmap);
    }catch(e){ console.warn('Albedo load failed', e); }
  }

  async function setMERSFromState(){
    try{
      const StateManager = window.MERS && window.MERS.StateManager;
      const ImageProcessor = window.MERS && window.MERS.ImageProcessor;
      if (!StateManager || !ImageProcessor) return;
      const state = StateManager.getState();
      if (!state || !state.out) return;
      const w = state.out.width, h = state.out.height;
      const frameW = state.anim && state.anim.w ? state.anim.w : w;
      const frameH = state.anim && state.anim.h ? state.anim.h : h;
      const frames = Math.max(1, Math.floor(h / frameH));
      const frameIndex = state.anim && state.anim.on ? (state.anim.i|0) : Math.min(state.anim ? (state.anim.i|0) : 0, frames-1);
      const frameY = frameIndex * frameH;

      // Build full-res offscreen (no letterboxing)
      const off = document.createElement('canvas');
      off.width = w; off.height = h;
      const offCtx = off.getContext('2d');
      offCtx.putImageData(ImageProcessor.renderForMode(state.out, state.mode, state.grayscale), 0, 0);

      // Crop current frame to its native pixel size
      const viewW = Math.min(frameW, w);
      const viewH = Math.min(frameH, Math.max(0, h - frameY));
      const mersTex = document.createElement('canvas');
      mersTex.width = viewW; mersTex.height = viewH;
      const mt = mersTex.getContext('2d');
      mt.imageSmoothingEnabled = false;
      mt.drawImage(off, 0, frameY, viewW, viewH, 0, 0, viewW, viewH);

      gl.bindTexture(gl.TEXTURE_2D, texMERS);
      gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, false);
      gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, mersTex);
    }catch(e){ console.warn('MERS upload failed', e); }
  }

  // Fallback init (1x1)
  gl.bindTexture(gl.TEXTURE_2D, texAlbedo);
  gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, 1,1,0, gl.RGBA, gl.UNSIGNED_BYTE, new Uint8Array([200,200,200,255]));
  gl.bindTexture(gl.TEXTURE_2D, texMERS);
  gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, 1,1,0, gl.RGBA, gl.UNSIGNED_BYTE, new Uint8Array([0,0,200,0]));

  // --- 6) Camera / controls ----------------------------------------------------
  let yaw = 0.6, pitch = 0.3, dist = 3.0;
  let panX = 0.0, panY = 0.0;
  let draggingRotate = false, draggingPan = false, lx=0, ly=0;
  const autoSpinInput = document.getElementById('gl_spin');
  const fov = Math.PI/4; // must match perspective fov
  canvas.addEventListener('contextmenu', (e)=> e.preventDefault());

  canvas.addEventListener('mousedown', (e)=>{
    if (e.button === 0) draggingRotate = true;
    else if (e.button === 2) draggingPan = true;
    lx=e.clientX; ly=e.clientY;
  });
  window.addEventListener('mouseup', ()=>{ draggingRotate=false; draggingPan=false; });
  window.addEventListener('mousemove', (e)=>{
    const dx=e.clientX-lx, dy=e.clientY-ly;
    lx=e.clientX; ly=e.clientY;
    if (draggingRotate){
      yaw   += dx * 0.005;
      pitch += dy * 0.005;
      pitch = Math.max(-1.3, Math.min(1.3, pitch));
    } else if (draggingPan){
      // Screen-space pan scaled by distance & FOV
      const scale = (2 * Math.tan(fov/2) * dist) / Math.max(1, canvas.height);
      panX -= dx * scale;
      panY += dy * scale;
    }
  });
  canvas.addEventListener('wheel', (e)=>{
    dist *= (1 + Math.sign(e.deltaY)*0.08);
    dist = Math.max(1.0, Math.min(12.0, dist));
  }, {passive:true});

  function resize(){
    const rect = canvas.getBoundingClientRect();
    const dpr  = Math.min(2, window.devicePixelRatio || 1);
    const w = Math.max(320, Math.floor(rect.width * dpr));
    const h = Math.max(240, Math.floor(rect.height * dpr));
    if (canvas.width !== w || canvas.height !== h){
      canvas.width = w; canvas.height = h;
    }
    gl.viewport(0,0,canvas.width, canvas.height);
  }
  window.addEventListener('resize', resize);
  resize();
// --- 7) Render loop ----------------------------------------------------------
  gl.clearColor(0.08,0.08,0.1,1);

  function frame(t){
    if (autoSpinInput && autoSpinInput.checked) yaw += 0.0035;
    resize();

    gl.enable(gl.DEPTH_TEST);
    gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);

    const proj = mat4_perspective(new Float32Array(16), Math.PI/4, canvas.width/canvas.height, 0.01, 100);
    let view = mat4_identity();
    // Apply pan in view space (right-click drag)
    view = mat4_translate(view, [-panX, -panY, -dist]);
    let model = mat4_identity();
    model = mat4_rotateY(model, yaw);
    model = mat4_rotateX(model, pitch);

    gl.useProgram(prog);
    gl.uniformMatrix4fv(loc.uProj, false, proj);
    gl.uniformMatrix4fv(loc.uView, false, view);
    gl.uniformMatrix4fv(loc.uModel, false, model);
    gl.uniform3fv(loc.uCamPos, new Float32Array([panX, panY, dist]));

    // Light from user-controlled elevation (keeps base horizontal aim)
    const elevEl = document.getElementById('gl_light_elev');
    const azEl = document.getElementById('gl_light_azim');
    const elev = elevEl ? (parseFloat(elevEl.value) * Math.PI/180) : (Math.PI/3);
    const az = azEl ? (parseFloat(azEl.value) * Math.PI/180) : (Math.atan2(0.3,0.5));
    // base horizontal unit vector rotated by azimuth (for directional default)
    const bx = 0.5, bz = 0.3; // default facing
    const bh = Math.hypot(bx, bz) || 1.0;
    const ux = bx/bh, uz = bz/bh;
    const rx = Math.cos(az)*ux - Math.sin(az)*uz;
    const rz = Math.sin(az)*ux + Math.cos(az)*uz;
    const hx = rx * Math.cos(elev);
    const hz = rz * Math.cos(elev);
    const lyDir = Math.sin(elev);
    const lightDir = vec3_norm([hx, lyDir, hz]);
    const lev = document.getElementById('gl_le_val'); if (lev) lev.textContent = Math.round(elev*180/Math.PI) + '°';
    const lav = document.getElementById('gl_la_val'); if (lav) lav.textContent = Math.round(az*180/Math.PI) + '°';
    const sfEl = document.getElementById('gl_side_fill');
    const sf = sfEl ? parseFloat(sfEl.value) : 0.25;
    gl.uniform1f(loc.uAmbient, 0.06);
    gl.uniform1f(loc.uSideFill, sf);
    const sfv = document.getElementById('gl_sf_val'); if (sfv) sfv.textContent = sf.toFixed(2);
    const lpEl = document.getElementById('gl_light_point');
    const ldEl = document.getElementById('gl_light_dist');
    const lyEl = document.getElementById('gl_light_y');
    const lp = lpEl ? !!lpEl.checked : false;
    const ld = ldEl ? parseFloat(ldEl.value) : 2.0;
    const ly = lyEl ? parseFloat(lyEl.value) : 1.5;
    gl.uniform1f(loc.uLightKind, lp ? 1.0 : 0.0);
    gl.uniform1f(loc.uLightDistance, ld);
    gl.uniform1f(loc.uLightAtten, 0.2);
    const ldv = document.getElementById('gl_ld_val'); if (ldv) ldv.textContent = ld.toFixed(2);
    const alEl = document.getElementById('gl_albedo_lock');
    gl.uniform1f(loc.uAlbedoLock, (alEl && alEl.checked) ? 1.0 : 0.0);
    const lyv = document.getElementById('gl_ly_val'); if (lyv) lyv.textContent = ly.toFixed(2);
    if (lp) {
      // Point light: position from azimuth, elevation, distance + optional Y offset
      const radial = Math.max(0.0, ld) * Math.cos(elev);
      const px = Math.cos(az) * radial;
      const py = Math.max(-100.0, Math.min(100.0, Math.sin(elev) * Math.max(0.0, ld) + ly));
      const pz = Math.sin(az) * radial;
      const Lpos = new Float32Array([px, py, pz]);
      gl.uniform3fv(loc.uLightPos, Lpos);
    } else {
      // Directional: use lightDir
      gl.uniform3fv(loc.uLightDir, new Float32Array(lightDir));
      gl.uniform3fv(loc.uLightPos, new Float32Array([0,0,0]));
    }
    const liEl = document.getElementById('gl_light_intensity');
    const lsEl = document.getElementById('gl_light_size');
    const li = liEl ? parseFloat(liEl.value) : 1.6;
    const ls = lsEl ? parseFloat(lsEl.value) : 0.12;
    gl.uniform1f(loc.uLightIntensity, li);
    gl.uniform1f(loc.uLightSize, ls);
    const liv = document.getElementById('gl_li_val'); if (liv) liv.textContent = li.toFixed(2);
    const lsv = document.getElementById('gl_ls_val'); if (lsv) lsv.textContent = ls.toFixed(2);

    gl.activeTexture(gl.TEXTURE0);
    gl.bindTexture(gl.TEXTURE_2D, texAlbedo);
    gl.uniform1i(loc.uAlbedo, 0);

    gl.activeTexture(gl.TEXTURE1);
    gl.bindTexture(gl.TEXTURE_2D, texMERS);
    gl.uniform1i(loc.uMERS, 1);

    gl.bindVertexArray(vao);
    gl.drawElements(gl.TRIANGLES, indexCount, gl.UNSIGNED_SHORT, 0);

    requestAnimationFrame(frame);
  }
  requestAnimationFrame(frame);

  // --- 8) Sync: recompute only + file load (avoid reacting to preview zoom) ----
  function safeWrapMethod(obj, name, after){
    if (!obj || !obj[name] || obj[name]._glWrapped) return false;
    const orig = obj[name];
    obj[name] = function(){
      const r = orig.apply(this, arguments);
      try { after(); } catch(e){}
      return r;
    };
    obj[name]._glWrapped = true;
    return true;
  }

  function hookRecompute(){
    const did = safeWrapMethod(window.MERS?.Core || {}, 'recompute', setMERSFromState);
    if (did) setMERSFromState(); // initial
    return did;
  }

  let tries = 0;
  const iv = setInterval(()=>{
    tries++;
    if (hookRecompute() || tries > 10) clearInterval(iv);
  }, 200);

  // Wire to file input so albedo is the true original image
  const fileTex = document.getElementById('fileTex');
  if (fileTex){
    const loadFile = ()=>{
      const f = fileTex.files && fileTex.files[0];
      if (f) setAlbedoFromFile(f);
    };
    fileTex.addEventListener('change', loadFile);
    if (fileTex.files && fileTex.files[0]) loadFile(); // in case already chosen
  }

  // --- 9) Pop-out / Dock + Drag ------------------------------------------------
  const headerRow = panel.querySelector('.row'); // first header row
  headerRow.classList.add('gl-drag-handle');
  const popBtn = document.getElementById('gl_pop');

  // Keep a docking anchor so we can restore position in the right column
  // dockParent is defined above based on wrapSrc / right column
  const dockAnchor = document.createComment('GLVIEWER_ANCHOR');
  if (wrapSrc) { dockParent.insertBefore(dockAnchor, wrapSrc.nextSibling); }
  else { dockParent.insertBefore(dockAnchor, panel.nextSibling); }

  function dock(){
    panel.classList.remove('gl-float');
    panel.style.left = panel.style.top = panel.style.right = panel.style.bottom = '';
    panel.style.width = '';
    if (popBtn) popBtn.textContent = 'Pop‑out';
    dockParent.insertBefore(panel, dockAnchor.nextSibling);
    localStorage.setItem('glViewerFloating','0');
  }
  function popout(){
    if (!panel.classList.contains('gl-float')){
      document.body.appendChild(panel);
      panel.classList.add('gl-float');
      // Restore saved position or default
      const saved = JSON.parse(localStorage.getItem('glViewerPos')||'{}');
      panel.style.left = (saved.left ?? 24) + 'px';
      panel.style.top  = (saved.top  ?? 24) + 'px';
      panel.style.width = (saved.width ?? 640) + 'px';
      if (popBtn) popBtn.textContent = 'Dock';
      localStorage.setItem('glViewerFloating','1');
    }
  }
  if (popBtn) popBtn.addEventListener('click', ()=>{
    if (panel.classList.contains('gl-float')) dock(); else popout();
  });

  // Dragging
  let dragging=false, ox=0, oy=0, startLeft=0, startTop=0;
  headerRow.addEventListener('mousedown', (e)=>{
    if (!panel.classList.contains('gl-float')) return;
    if ((e.target.tagName === 'INPUT') || (e.target.tagName === 'BUTTON') || e.target.type === 'range') return;
    dragging=true;
    panel.classList.add('gl-grabbing');
    const rect = panel.getBoundingClientRect();
    startLeft = rect.left; startTop = rect.top;
    ox = e.clientX; oy = e.clientY;
    e.preventDefault();
  });
  window.addEventListener('mousemove', (e)=>{
    if (!dragging) return;
    const nx = startLeft + (e.clientX - ox);
    const ny = startTop + (e.clientY - oy);
    const vw = window.innerWidth, vh = window.innerHeight;
    const rect = panel.getBoundingClientRect();
    const clampedX = Math.max(8, Math.min(vw - rect.width - 8, nx));
    const clampedY = Math.max(8, Math.min(vh - 48, ny));
    panel.style.left = clampedX + 'px';
    panel.style.top  = clampedY + 'px';
  });
  window.addEventListener('mouseup', ()=>{
    if (!dragging) return;
    dragging=false;
    panel.classList.remove('gl-grabbing');
    const r = panel.getBoundingClientRect();
    localStorage.setItem('glViewerPos', JSON.stringify({left: Math.round(r.left), top: Math.round(r.top), width: Math.round(r.width)}));
  });

  // Restore previous floating state
  if (localStorage.getItem('glViewerFloating') === '1') popout();
})();
</script>

</body>
</html>
<!-- === Patch: Sync Original texture canvas (src) with pan/zoom & picking === -->
<script>
(function(){
  function ready(fn){ if (document.readyState !== 'loading') fn(); else document.addEventListener('DOMContentLoaded', fn); }
  ready(function(){
    if (!window.MERS || !MERS.PreviewManager) return;

    // Give the Original texture wrapper a stable id and fixed height like the top previews
    (function ensureSrcWrap(){
      const wrap = document.getElementById('canvasSrc')?.closest('.canvasWrap');
      if (wrap && !wrap.id) wrap.id = 'wrapSrc';
      const st = document.createElement('style');
      st.textContent = '#wrapSrc{height:384px;}';
      document.head.appendChild(st);
    })();

    // Draw the Original (src) canvas using the same pan/zoom/frame transform
    (function patchDrawPreview(){
      const orig = MERS.PreviewManager.drawPreview;
      MERS.PreviewManager.drawPreview = function(){
        orig && orig.apply(this, arguments);

        const state = MERS.StateManager.getState();
        if (!state || !state.src) return;

        const cs = document.getElementById('canvasSrc');
        if (!cs) return;
        const ctx = cs.getContext('2d');

        // Resize backing store to CSS size
        const rect = cs.getBoundingClientRect();
        const wcss = Math.round(rect.width), hcss = Math.round(rect.height);
        if (cs.width !== wcss || cs.height !== hcss) { cs.width = wcss; cs.height = hcss; }

        // Clear
        ctx.save();
        ctx.setTransform(1,0,0,1,0,0);
        ctx.clearRect(0,0,cs.width,cs.height);

        // Compute transform (identical to OUT/REF)
        const sw = state.src.width, sh = state.src.height;
        const frameW = state.anim.w || sw, frameH = state.anim.h || sh;
        const frames = Math.max(1, Math.floor(sh / frameH));
        const frameY = state.anim.on ? state.anim.i * frameH : Math.min(state.anim.i, frames - 1) * frameH;
        const viewW = Math.min(frameW, sw), viewH = Math.min(frameH, sh - frameY);
        const fit = Math.min(cs.width / viewW, cs.height / viewH);
        const scale = fit * state.zoom;
        const dx = Math.round((cs.width - viewW * scale) / 2 + state.panX);
        const dy = Math.round((cs.height - viewH * scale) / 2 + state.panY);

        // Render Original (src) as full RGBA (independent of preview mode)
        const tmp = document.createElement('canvas');
        tmp.width = sw; tmp.height = sh;
        tmp.getContext('2d').putImageData(MERS.ImageProcessor.renderForMode(state.src, 'rgba', false), 0, 0);

        ctx.setTransform(scale, 0, 0, scale, dx, dy);
        ctx.imageSmoothingEnabled = false;
        ctx.drawImage(tmp, 0, frameY, viewW, viewH, 0, 0, viewW, viewH);
        ctx.restore();
      };
    })();

    // Make color picking on the Original (src) canvas use the same pan/zoom mapping
    (function patchPickColor(){
      if (!MERS.PaintTool || typeof MERS.PaintTool.pickColorFromEvent !== 'function') return;
      MERS.PaintTool.pickColorFromEvent = function(e, imgType){
        const state = MERS.StateManager.getState();
        const paintState = MERS.StateManager.getPaintState();
        let imgd = null, canvas = null;
        if (imgType === 'ref' && state.ref) {
          imgd = state.ref; canvas = document.getElementById('canvasRef');
        } else if (imgType === 'src' && state.src) {
          imgd = state.src; canvas = document.getElementById('canvasSrc');
        } else if (imgType === 'out' && state.out) {
          imgd = state.out; canvas = document.getElementById('canvasOut');
        }
        if (!imgd || !canvas) return;

        const rect = canvas.getBoundingClientRect();
        const xCanvas = e.clientX - rect.left;
        const yCanvas = e.clientY - rect.top;

        const w = imgd.width, h = imgd.height;
        const frameW = state.anim.w || w;
        const frameH = state.anim.h || h;
        const frames = Math.max(1, Math.floor(h / frameH));
        const frameY = state.anim.on ? state.anim.i * frameH : Math.min(state.anim.i, frames - 1) * frameH;
        const viewW = Math.min(frameW, w);
        const viewH = Math.min(frameH, h - frameY);

        const fit = Math.min(rect.width / viewW, rect.height / viewH);
        const scale = fit * state.zoom;
        const dx = Math.round((rect.width - viewW * scale) / 2 + state.panX);
        const dy = Math.round((rect.height - viewH * scale) / 2 + state.panY);

        const ix = (xCanvas - dx) / scale;
        const iy = (yCanvas - dy) / scale;

        const xImg = Math.floor(ix + 1e-9);
        const yImg = Math.floor(iy + 1e-9) + frameY;
        if (xImg < 0 || xImg >= w || yImg < 0 || yImg >= h) return;

        const idx = (yImg * w + xImg) * 4, data = imgd.data;
        const r = data[idx], g = data[idx + 1], b = data[idx + 2], a = data[idx + 3];

        // Respect current channel mode; RGBA does not pick
        const mode = state && state.mode;
        if (!paintState || !mode || mode === 'rgba') return;

        const getAlpha = () => (paintState.copyAlpha ? a : 255);
        let newColor;
        switch (mode) {
          case 'r': newColor = { r, g: 0, b: 0, a: getAlpha() }; break;
          case 'g': newColor = { r: 0, g, b: 0, a: getAlpha() }; break;
          case 'b': newColor = { r: 0, g: 0, b, a: getAlpha() }; break;
          case 'a': newColor = { r: 0, g: 0, b: 0, a: getAlpha() }; break;
          default: return;
        }
        paintState.color = newColor;

        const colorInput = document.getElementById('brushColor');
        if (colorInput) {
          const toHex = v => ('0' + Math.max(0, Math.min(255, v)).toString(16)).slice(-2);
          colorInput.value = '#' + toHex(newColor.r) + toHex(newColor.g) + toHex(newColor.b);
        }
      };
    })();
  });
})();
</script>
<!-- === GitHub Auto-Reference for MERS (Bedrock samples) === -->
<style>
  /* Layout */
  .gh-top {
    display: inline-flex;
    align-items: center;
    gap: 10px;
    flex-wrap: wrap;
  }
  .gh-sub { margin-top: 8px; }
  .gh-note { flex-basis: 100%; margin-top: 6px; font-size: 12px; color: #ef4444; }

  /* Pill button */
  #autoGithubRefWrap.toggle {
    display: inline-flex;
    align-items: center;
    gap: 10px;
    padding: 8px 14px;
    border: 1px solid rgba(0,0,0,.20);
    border-radius: 9999px;
    cursor: pointer;
    user-select: none;
    background: #ffffff;
    box-shadow: 0 1px 3px rgba(0,0,0,.12);
    margin-right: 8px;
  }
  #autoGithubRefWrap.toggle:hover {
    border-color: rgba(0,0,0,.35);
    box-shadow: 0 2px 8px rgba(0,0,0,.12);
  }
  #autoGithubRefWrap .label {
    font-weight: 600;
    letter-spacing: .2px;
    color: #1f2937;
  }
  #autoGithubRefWrap:focus-visible { outline: 2px solid #4c9ffe; outline-offset: 2px; }

  /* Search box + dropdown */
  .gh-search-wrap { position: relative; display: inline-block; }
  #ghSearch {
    display: inline-block;
    width: 360px;
    padding: 8px 10px;
    border: 1px solid rgba(0,0,0,.25);
    border-radius: 10px;
    background: #fff;
    color: #111827;
    box-shadow: 0 1px 2px rgba(0,0,0,.06) inset;
  }
  #ghSearch::placeholder { color: #6b7280; }
  .gh-suggest {
    position: absolute;
    left: 0;
    right: 0;
    top: calc(100% + 4px);
    background: #fff;
    border: 1px solid rgba(0,0,0,.2);
    border-radius: 10px;
    box-shadow: 0 8px 18px rgba(0,0,0,.18);
    max-height: 280px;
    overflow: auto;
    z-index: 9999;
    display: none;
  }
  .gh-suggest ul { list-style: none; margin: 0; padding: 6px 0; }
  .gh-suggest li {
    padding: 8px 12px;
    cursor: pointer;
    display: flex;
    align-items: baseline;
    gap: 8px;
  }
  .gh-suggest li .base { font-weight: 600; color: #111827; }
  .gh-suggest li .dir { font-size: 12px; color: #6b7280; }
  .gh-suggest li:hover, .gh-suggest li.active { background: #f3f4f6; }
</style>
<script>
/* === GitHub Auto-Reference for MERS (Bedrock samples) — v7 (custom live dropdown) === */
(function () {
  const OWNER = 'Mojang';
  const REPO  = 'bedrock-samples';
  const REF   = 'preview';
  const ROOT  = 'resource_pack/textures/';
  const API_TREE = `https://api.github.com/repos/${OWNER}/${REPO}/git/trees/${REF}?recursive=1`;
  const RAW_BASE = `https://raw.githubusercontent.com/${OWNER}/${REPO}/${REF}/`;

  const UI = {
    row: null, chk: null, btnApply: null, status: null, folderHint: null, toggleWrap: null,
    searchWrap: null, input: null, suggest: null
  };
  const Index = { ready:false, items:[], byPath:new Map(), byBase:new Map() };
  let LastTextureFile = null;
  let activeIndex = -1;

  function basename(p){ return p.split('/').pop(); }
  function dirname(p){ const i = p.lastIndexOf('/'); return i>=0 ? p.slice(0,i) : ''; }
  function tokens(name){
    return name.toLowerCase()
      .replace(/\.[a-z0-9]+$/,'')
      .replace(/_mers$/,'')
      .split(/[^a-z0-9]+/g).filter(Boolean)
      .filter(t => t !== 'mers');
  }
  function stem(name){
    return name.toLowerCase()
      .replace(/\.[a-z0-9]+$/,'')
      .replace(/_mers$/,'');
  }

  const FOLDER_PRIORITY = {
    'entity': 600, 'entities': 600,
    'items': 200, 'item': 200,
    'blocks': 100, 'block': 100,
    'ui': 50, 'environment': 50, 'misc': 25,
  };
  function folderScore(dir){
    const parts = dir.toLowerCase().split('/');
    let s = 0;
    for (const p of parts){ if (FOLDER_PRIORITY[p]) s += FOLDER_PRIORITY[p]; }
    return s;
  }
  function matchesFolderHint(dir, hint){
    if (!hint || hint === 'auto') return true;
    dir = dir.toLowerCase();
    if (hint === 'blocks') return dir.includes('/block/') || dir.includes('/blocks/');
    return dir.includes('/' + hint + '/');
  }
  function setStatus(msg){ if (UI.status) UI.status.textContent = msg || ''; }

  async function ensureIndex(){
    if (Index.ready) return;
    setStatus('Indexing Mojang textures from GitHub…');
    const res = await fetch(API_TREE);
    if (!res.ok) throw new Error('GitHub API failed: ' + res.status);
    const json = await res.json();
    const list = (json.tree || [])
      .filter(n => n.type === 'blob' && n.path.startsWith(ROOT) && n.path.toLowerCase().endsWith('_mers.tga'))
      .map(n => ({
          path: n.path,
          base: basename(n.path),
          stem: stem(basename(n.path)),
          dir: dirname(n.path),
      }));
    list.forEach(it => it.toks = tokens(it.base));
    Index.items = list;
    Index.byPath = new Map(list.map(it => [it.path, it]));
    Index.byBase = new Map();
    for (const it of list){
      const arr = Index.byBase.get(it.base) || [];
      arr.push(it);
      Index.byBase.set(it.base, arr);
    }
    Index.ready = true;
    setStatus(`Indexed ${list.length} _mers.tga files.`);
  }

  async function fetchAndApply(path){
    setStatus('Fetching ' + basename(path) + ' …');
    const res = await fetch(RAW_BASE + path);
    if (!res.ok) throw new Error('Fetch failed: ' + res.status);
    const buf = await res.arrayBuffer();

    if (!window.MERS || !MERS.ImageProcessor || !MERS.ImageProcessor.parseTGA) {
      setStatus('MERS runtime not detected.');
      return;
    }
    const ref = MERS.ImageProcessor.parseTGA(new DataView(buf));
    const state = MERS.StateManager && MERS.StateManager.getState ? MERS.StateManager.getState() : (window.MERS_STATE ||= {});
    state.ref = ref;
    const nameSpan = document.getElementById('refName');
    if (nameSpan) nameSpan.textContent = 'GitHub: ' + basename(path);

    try { MERS.PreviewManager && MERS.PreviewManager.drawReference && MERS.PreviewManager.drawReference(); } catch(e){}
    try { MERS.UIManager && MERS.UIManager.updateRefControls && MERS.UIManager.updateRefControls(); } catch(e){}
    try { MERS.Core && MERS.Core.rebuildRefColorMap && MERS.Core.rebuildRefColorMap(); } catch(e){}
    try { MERS.Core && MERS.Core.recompute && MERS.Core.recompute(); } catch(e){}
    setStatus('Applied ' + basename(path));
    hideSuggest();
  }

  function bestAutoMatchFor(srcName, folderHint){
    const srcStem = stem(srcName);
    const srcToks = tokens(srcName);
    const srcSet  = new Set(srcToks);

    let best = null;
    let bestScore = -1;

    for (const it of Index.items){
      if (!matchesFolderHint(it.dir, folderHint)) continue;

      const itStem = it.stem;
      const itToks = it.toks;

      const intersect = itToks.filter(t => srcSet.has(t)).length;
      const extraTokPenalty = Math.max(0, itToks.length - intersect);

      const exactStem = (itStem === srcStem) ? 1 : 0;
      const prefixStem = (!exactStem && itStem.startsWith(srcStem + '_')) ? 1 : 0;

      let score = 0;
      score += exactStem ? 100000 : 0;
      score += prefixStem ? 30000 : 0;
      score += intersect * 300;
      score -= extraTokPenalty * 120;
      score += folderScore(it.dir);
      score -= itStem.length;

      if (score > bestScore){
        bestScore = score;
        best = it;
      }
    }
    if (!best && folderHint && folderHint !== 'auto'){
      return bestAutoMatchFor(srcName, 'auto');
    }
    return best && best.path;
  }

  async function tryAutoForCurrentTexture(){
    const texNameEl = document.getElementById('texName');
    const srcName = texNameEl ? texNameEl.textContent : '';
    if (!srcName || !UI.chk || !UI.chk.checked) return;

    try {
      await ensureIndex();
      const hint = UI.folderHint ? UI.folderHint.value : 'auto';
      const path = bestAutoMatchFor(srcName, hint);
      if (path){
        await fetchAndApply(path);
      } else {
        setStatus('No direct match. Start typing to search.');
        UI.input && UI.input.focus();
      }
    } catch (e){
      console.error(e);
      setStatus('Error: ' + e.message);
    }
  }

  function filterSuggestions(q){
    if (!q) return [];
    const qToks = q.toLowerCase().split(/[^a-z0-9]+/g).filter(Boolean);
    const hint = UI.folderHint ? UI.folderHint.value : 'auto';
    const out = [];
    for (const it of Index.items){
      if (!matchesFolderHint(it.dir, hint)) continue;
      const base = it.base.toLowerCase();
      let ok = true;
      for (const t of qToks){ if (!base.includes(t)) { ok = false; break; } }
      if (ok) out.push(it);
      if (out.length >= 100) break;
    }
    return out;
  }

  function showSuggest(items){
    if (!items || !items.length) { hideSuggest(); return; }
    UI.suggest.innerHTML = '<ul></ul>';
    const ul = UI.suggest.querySelector('ul');
    items.forEach((it, idx) => {
      const li = document.createElement('li');
      li.innerHTML = `<span class="base">${it.base}</span><span class="dir">${it.dir.replace(ROOT,'')}</span>`;
      li.dataset.path = it.path;
      li.addEventListener('mouseenter', ()=> setActive(idx));
      li.addEventListener('mousedown', (e)=>{ e.preventDefault(); }); // avoid losing focus
      li.addEventListener('click', ()=> fetchAndApply(it.path));
      ul.appendChild(li);
    });
    activeIndex = -1;
    UI.suggest.style.display = 'block';
  }
  function hideSuggest(){ UI.suggest.style.display = 'none'; activeIndex = -1; }
  function setActive(idx){
    const lis = Array.from(UI.suggest.querySelectorAll('li'));
    lis.forEach(li => li.classList.remove('active'));
    if (idx >=0 && idx < lis.length){
      lis[idx].classList.add('active');
      activeIndex = idx;
    }
  }
  function moveActive(delta){
    const lis = Array.from(UI.suggest.querySelectorAll('li'));
    if (!lis.length){ activeIndex = -1; return; }
    let idx = activeIndex + delta;
    if (idx < 0) idx = lis.length - 1;
    if (idx >= lis.length) idx = 0;
    setActive(idx);
  }
  function pickActive(){
    const lis = Array.from(UI.suggest.querySelectorAll('li'));
    if (activeIndex >=0 && activeIndex < lis.length){
      const path = lis[activeIndex].dataset.path;
      fetchAndApply(path);
      return true;
    }
    return false;
  }

  async function onInput(){
    await ensureIndex();
    const q = (UI.input.value || '').trim();
    const items = filterSuggestions(q);
    showSuggest(items);
  }

  function injectUI(){
    const refPanel = document.querySelector('.panel.upload') || document.body;
    const row = document.createElement('div');
    row.className = 'row mt';
    row.innerHTML = `
      <div class="gh-top">
        <label id="autoGithubRefWrap" class="toggle" role="switch" aria-checked="false" title="When enabled, auto-apply a matching MERS from Mojang's GitHub">
          <input id="autoGithubRef" type="checkbox" hidden>
          <span class="label">Auto apply MERS via Bedrock Github</span>
        </label>
        <div class="gh-note">Auto apply can mess up the reference MERS. Use the search to ensure proper import</div>
        <span class="gh-search-wrap">
          <input id="ghSearch" type="search" placeholder="Search MERS .tga… (type to see dropdown)">
          <div id="ghSuggest" class="gh-suggest"></div>
        </span>
        <span class="muted" id="ghStatus"></span>
      </div>
      <div class="gh-sub">
        <select id="ghFolderHint" class="btn">
          <option value="auto">Folder hint: Auto</option>
          <option value="entity">Folder hint: Entity</option>
          <option value="blocks">Folder hint: Blocks</option>
          <option value="items">Folder hint: Items</option>
          <option value="ui">Folder hint: UI</option>
          <option value="environment">Folder hint: Environment</option>
          <option value="misc">Folder hint: Misc</option>
        </select>
      </div>
    `;
    const rows = refPanel.querySelectorAll('.row.mt');
    const anchor = rows[1] || rows[rows.length-1] || refPanel;
    anchor.parentNode.insertBefore(row, anchor.nextSibling);

    UI.row = row;
    UI.toggleWrap = row.querySelector('#autoGithubRefWrap');
    UI.chk = row.querySelector('#autoGithubRef');
    UI.folderHint = row.querySelector('#ghFolderHint');
    UI.input = row.querySelector('#ghSearch');
    UI.suggest = row.querySelector('#ghSuggest');
    UI.status = row.querySelector('#ghStatus');

    // Toggle behavior
    UI.toggleWrap.addEventListener('click', (e)=>{
      if (e.target && e.target.tagName === 'INPUT') return;
      UI.chk.checked = !UI.chk.checked;
      UI.toggleWrap.setAttribute('aria-checked', UI.chk.checked ? 'true' : 'false');
      if (UI.chk.checked) tryAutoForCurrentTexture();
    });
    UI.toggleWrap.addEventListener('keydown', (e)=>{
      if (e.key === ' ' || e.key === 'Enter'){
        e.preventDefault();
        UI.chk.checked = !UI.chk.checked;
        UI.toggleWrap.setAttribute('aria-checked', UI.chk.checked ? 'true' : 'false');
        if (UI.chk.checked) tryAutoForCurrentTexture();
      }
    });
    UI.toggleWrap.setAttribute('tabindex', '0');

    // Search interactions
    UI.input.addEventListener('input', onInput);
    UI.input.addEventListener('focus', onInput);
    UI.input.addEventListener('keydown', (e)=>{
      if (e.key === 'ArrowDown'){ e.preventDefault(); moveActive(1); }
      else if (e.key === 'ArrowUp'){ e.preventDefault(); moveActive(-1); }
      else if (e.key === 'Enter'){ e.preventDefault(); if (!pickActive()) onInput(); }
      else if (e.key === 'Escape'){ hideSuggest(); }
    });
    UI.input.addEventListener('blur', ()=> setTimeout(hideSuggest, 150) );
    UI.folderHint.addEventListener('change', onInput);
  }

  function hookTextureLoad(){
    if (!window.MERS || !MERS.FileManager || !MERS.FileManager.loadTexture) return;
    const orig = MERS.FileManager.loadTexture;
    MERS.FileManager.loadTexture = function(file){
      LastTextureFile = file || null;
      const ret = orig.apply(this, arguments);
      setTimeout(()=>{
        if (UI && UI.folderHint && UI.folderHint.value === 'auto'){
          // leave as auto; user can change; no auto seed here to avoid surprise
        }
        tryAutoForCurrentTexture();
      }, 0);
      return ret;
    };
  }

  function ready(fn){ if (document.readyState !== 'loading') fn(); else document.addEventListener('DOMContentLoaded', fn); }
  ready(function(){
    injectUI();
    hookTextureLoad();
  });
})();
</script>
